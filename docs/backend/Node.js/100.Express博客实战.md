# 【Node.js实战系列】Express 从零搭建博客系统(一)

## 前言

> 哈喽，大家好，这里是胖芙，咱这系列的文章主打的就是一个通俗易懂。这个系列的文章会从零开始教你怎么使用 Express.js 去搭建一个能用的博客系统，是真的从零，手把手的那种！！！让你打通 JS 前后端任督二脉！
>
> 本系列文章也会收录在公众号《泡芙学前端》中，持续更新中... 欢迎关注

首先要知道我们现在要做个怎样的系统，比如博客能干嘛？

那它的核心功能肯定是对于文章的增删改查嘛，所以我们就有了以下的几个核心接口：

- 发表博客
- 分页查看博客列表
- 根据id查看博客详情
- 根据id删除博客(软删除)
- 根据id修改博客内容
- 上传文件（比如博客内的图片），前期我们先把图片存本地，后面可以改成上传到 OSS

好了，这几个接口搞完了其实博客系统的雏形就已经有了。

但是哎，好像还不太够，还缺点啥？所以接下来我们继续给博客添加功能，比如用户登录注册功能：

- 用户注册
- 用户登录

嗯，开始有点内味了，到这里一个基本的博客系统就其实已经可以自己用起来了。

接下来我们就继续锦上添花，比如我们为了让博客能分类，来添加一个标签系统，可以给博客打上分类的标签，比如 JavaScript、Node.js、React 等标签

- 新增标签
- 查询标签
- 删除标签(软删除)

到这里为止一个博客的雏形就已经有了，后续可以基于这个雏形来添加更多的功能，比如接入 Redis 缓存进行优化等，不过那都是后话了，我们这里就先把一个雏形从零开始搭建完成。

我们本系列教程只写后端，大家如果有兴趣的话可以自己写一下前端，或者如果后续反馈好，我也可以把前端部分给补上。

废话不多说，直接开始吧。首先我们先来完成基本环境的一个搭建工作哈

## 1.搭建初始环境

- 找到一个地方创建目录，比如 express-blog

- 进入目录，控制台运行 `npm init -y`

- 修改 package.json 中的 scripts 字段为下面代码，作为启动入口，推荐安装 nodemon 这个包，当文件变更时它可以自动重启服务

  - `npm i nodemon -g` 安装到全局

  - ```json
    "scripts": {
      "start": "nodemon app.js"
    },
    ```

- 安装依赖：`npm install express sequelize mysql2 body-parser cors bcrypt jsonwebtoken multer`
  - express: 我们要用的服务端框架
  - sequelize: 操作数据库的 orm
  - mysql2: 数据库驱动
  - body-parser: 用来解析 request body 的内容
  - cors: 解决跨域
  - bcrypt: 密码加密和解密
  - jsonwebtoken: 登录时生成 token 下发
  - multer: 用于上传文件

上面搞完后，我们就得到了这样的一个 package.json 文件

```json
{
  "name": "expree-blog",
  "version": "1.0.0",
  "description": "",
  "main": "app.js",
  "scripts": {
    "start": "nodemon app.js"
  },
  "keywords": [],
  "author": "",
  "license": "ISC",
  "dependencies": {
    "bcrypt": "^5.1.0",
    "body-parser": "^1.20.2",
    "cors": "^2.8.5",
    "express": "^4.18.2",
    "jsonwebtoken": "^9.0.0",
    "multer": "1.4.5-lts.1",
    "mysql2": "^3.3.3",
    "sequelize": "^6.31.1"
  }
}
```

到这里我们就完成了第一步工作，接下来我们就要创建目录结构了，最终项目完成时的目录结构长这个样子

```xml
expree-blog                   // 根目录
├── app.js                    // 项目主入口
├── config                    // 数据库配置
│   └── database.js
├── controllers               // 控制器，写逻辑的地方
│   ├── authController.js     // 登录注册控制器
│   ├── blogController.js     // 博客控制器
│   ├── fileController.js     // 文件控制器
│   └── tagController.js      // 标签控制器
├── middleware                // 中间件
│   ├── authMiddleware.js     // 鉴权中间件
│   └── fileMiddleware.js     // 文件处理中间件
├── models                    // 数据库模型
│   ├── Blog.js
│   ├── Tag.js
│   └── User.js
├── package.json
├── routes                    // 路由
│   ├── auth.js
│   ├── blogs.js
│   ├── file.js
│   └── tags.js
└── tempFiles                 // 存储上传的文件
```

## 2.数据库配置

这里可以启动自己的本地 mysql 数据库，然后填入对应信息即可，不知道怎么安装 mysql 的可以网上查下相关教程，可以使用 docker 安装，或者直接去官网下载安装包然后装到本地。我自己的话是用的 Docker

```js
const { Sequelize } = require("sequelize");

const sequelize = new Sequelize(
  // 数据库名称
  "your_database_name",
  // 数据库用户名
  "your_username",
  // 数据库密码
  "your_password",
  {
    // 如果是远程数据库，可以填写 ip 地址
    host: "localhost",
    dialect: "mysql",
  }
);

module.exports = sequelize;
```

当数据库启动起来之后，改一下上面的参数即可

## 3.构建数据库模型

现在我们要在 `models/` 目录下创建下面这几个模型文件：

- `User.js`：用户模型
- `Blog.js`：博客模型
- `Tag.js`：标签模型

然后在各个模型中去定义相应的字段：

### 用户模型

```js
// models/User.js

const { DataTypes, Model } = require("sequelize");
const sequelize = require("../config/database");

class User extends Model {}

User.init(
  {
    username: {
      comment: "用户名",
      type: DataTypes.STRING,
      allowNull: false,
      unique: true,
    },
    password: {
      comment: "密码",
      type: DataTypes.STRING,
      allowNull: false,
    },
    nickname: {
      comment: "昵称",
      type: DataTypes.STRING,
      allowNull: false,
    },
    lastOnlineTime: {
      comment: "最后登陆时间",
      type: DataTypes.DATE,
      allowNull: true,
    },
  },
  {
    sequelize,
    modelName: "User",
  }
);

module.exports = User;
```

### 博客模型

```js
// models/Blog.js

const { DataTypes, Model } = require("sequelize");
const sequelize = require("../config/database");
const User = require("./User");
const Tag = require("./Tag");

class Blog extends Model {}

Blog.init(
  {
    title: {
      comment: "标题",
      type: DataTypes.STRING,
      allowNull: false,
    },
    content: {
      comment: "博客内容",
      type: DataTypes.TEXT,
      allowNull: false,
    },
    coverImage: {
      comment: "封面图",
      type: DataTypes.STRING,
    },
    isDeleted: {
      comment: "是否已经删除",
      type: DataTypes.BOOLEAN,
      allowNull: false,
      defaultValue: false,
    },
  },
  {
    sequelize,
    modelName: "Blog",
  }
);

// 一篇博客可以对应多个标签
// 一个标签也可以对应到多篇博客

// 博客与标签的关联关系
Blog.belongsToMany(Tag, {
  through: "Blog_Tag",
  as: "tags",
});

// 标签和博客的关联关系
Tag.belongsToMany(Blog, {
  through: "Blog_Tag",
  as: "blogs",
});

// 一篇博客只能属于一个用户
// 一个用户可以拥有多篇博客

// 博客与用户的关联关系
Blog.belongsTo(User, { foreignKey: "userId", as: "user" });
User.hasMany(Blog, { foreignKey: "userId", as: "user" });

module.exports = Blog;
```

### 标签模型

```js
// models/Tag.js

const { DataTypes, Model } = require("sequelize");
const sequelize = require("../config/database");
class Tag extends Model {}

Tag.init(
  {
    name: {
      comment: "标签名称",
      type: DataTypes.STRING,
      allowNull: false,
      unique: true,
    },
    isDeleted: {
      comment: "是否已经删除",
      type: DataTypes.BOOLEAN,
      allowNull: false,
      defaultValue: false,
    },
  },
  {
    sequelize,
    modelName: "Tag",
  }
);

module.exports = Tag;
```

## 4.初始化主入口

```js
const express = require("express");
const bodyParser = require("body-parser");
const cors = require("cors");
const path = require("path");
const authRoutes = require("./routes/auth");
const blogRoutes = require("./routes/blogs");
const tagRoutes = require("./routes/tags");
const fileRoutes = require("./routes/file");
const sequelize = require("./config/database");

const app = express();

// 中间件
// 用来解析 post body x-www-form-urlencoded 格式数据
app.use(bodyParser.urlencoded({ extended: false }));
// 用来解析 post body json 格式数据
app.use(bodyParser.json());
// 处理跨域
app.use(cors());
// 提供静态文件访问
app.use("/tempFiles", express.static(path.join(__dirname, "tempFiles")));

// 路由
app.use("/auth", authRoutes);
app.use("/blogs", blogRoutes);
app.use("/tags", tagRoutes);
app.use("/upload", fileRoutes);

// 数据库同步
sequelize
  .sync()
  .then(() => {
    console.log("Database synced");
  })
  .catch((error) => {
    console.error("Error syncing database:", error);
  });

// 启动服务器
const port = process.env.PORT || 3000;
app.listen(port, () => {
  console.log(`Server is running on port ${port}`);
});
```

## 5. 初始化路由

这里我们采用 Restful 风格的路由

### 登录注册路由

```js
// routes/auth.js

const express = require('express');
const router = express.Router();
const authController = require('../controllers/authController');

router.post('/register', authController.register);
router.post('/login', authController.login);

module.exports = router;
```

### 博客路由

```js
// routes/blogs.js

const express = require('express');
const router = express.Router();
const blogController = require('../controllers/blogController');

// 创建博客
router.post('/create', blogController.createBlog);
// 查询博客列表
router.get('/query', blogController.getBlogList);
// 根据 id 查询博客详情
router.get('/query/:id', blogController.getBlogById);
// 根据 id 修改博客
router.patch('/update/:id', blogController.updateBlog);
// 根据 id 删除博客
router.delete('/delete/:id', blogController.deleteBlog);

module.exports = router;
```

### 标签路由

```js
// routes/tags.js

const express = require('express');
const router = express.Router();
const tagController = require('../controllers/tagController');

// 创建标签
router.post('/create', tagController.createTag);
// 查询所有标签
router.get('/query', tagController.getTags);
// 根据 id 删除标签
router.delete('/delete/:id', tagController.deleteTag);

module.exports = router;
```

### 文件路由

```js
// routes/file.js
const express = require("express");
const router = express.Router();
const fileController = require("../controllers/fileController");

// 目前只有一个上传文件接口
router.post("/file", fileController.uploadFile);

module.exports = router;
```

## 6.初始化控制器

### 登录注册

```js
// 注册
async function register(req, res) {
  // todo
}

// 登录
async function login(req, res) {
  // todo
}

module.exports = { register, login };
```

### 博客

```js
async function createBlog(req, res) {
  // todo
}

async function getBlogList(req, res) {
  // todo
}

async function getBlogById(req, res) {
  // todo
}

async function updateBlog(req, res) {
  // todo
}

async function deleteBlog(req, res) {
  // todo
}

module.exports = {
  createBlog,
  getBlogList,
  getBlogById,
  updateBlog,
  deleteBlog,
};
```

### 标签

```js
async function createTag(req, res) {
  // todo
}

async function getTags(req, res) {
  // todo
}

async function updateTag(req, res) {
  // todo
}

async function deleteTag(req, res) {
  // todo
}

module.exports = { createTag, getTags, updateTag, deleteTag };
```

### 上传文件

```js
async function uploadFile(req, res) {
  // todo
}

module.exports = { uploadFile };
```

## 小结

以上就是关于 Express 从零搭建博客系统的初始化相关内容了~

下一篇文章我们将完成登录和注册功能~，来实现 token 的下发和校验功能

如果想要实时收到文章的更新，欢迎关注公众号《泡芙学前端》，同步更新文章中~

# 【Node.js实战】实现登录注册-Express 搭建博客(二)
## 前言

> 哈喽，大家好，这里是胖芙，咱这系列的文章主打的就是一个通俗易懂。这个系列的文章会从零开始教你怎么使用 Express.js 去搭建一个能用的博客系统，是真的从零，手把手的那种！！！让你打通 JS 前后端任督二脉！
>
> 本系列文章也会收录在公众号《泡芙学前端》中，持续更新中... 欢迎关注

书接上文 [【Node.js实战】Express 从零搭建博客系统(一)](https://juejin.cn/post/7240342069997715511)

上一篇文章中我们已经把项目结构搭建好了，这里就可以直接开始编写功能了。

那么本章节中我们就来实现登录和注册功能，接下来再让我们来看一眼用户模型

## 用户模型定义

主要包括用户名、密码、昵称、最后的登录时间

```js
// models/User.js

const { DataTypes, Model } = require("sequelize");
const sequelize = require("../config/database");

class User extends Model {}

User.init(
  {
    username: {
      comment: "用户名",
      type: DataTypes.STRING,
      allowNull: false,
      unique: true,
    },
    password: {
      comment: "密码",
      type: DataTypes.STRING,
      allowNull: false,
    },
    nickname: {
      comment: "昵称",
      type: DataTypes.STRING,
      allowNull: false,
    },
    lastOnlineTime: {
      comment: "最后登陆时间",
      type: DataTypes.DATE,
      allowNull: true,
    },
  },
  {
    sequelize,
    modelName: "User",
  }
);

module.exports = User;
```

定义好了字段之后我们就可以开始写接口了

## 定义接口

我们现在要实现两个接口：

*   localhost:3000/auth/login： 登录
*   localhost:3000/auth/register： 注册

```js
// 根目录/app.js
... 具体代码可以看上一章节的实现

// 路由
app.use("/auth", authRoutes);

...
```

## 定义路由

```js
// routes/auth.js

const express = require('express');
const router = express.Router();
const authController = require('../controllers/authController');

// 注册控制器
router.post('/register', authController.register);
// 登录控制器
router.post('/login', authController.login);

module.exports = router;
```

## 定义控制器

### 注册

接下来我们先来看注册功能，登录功能的本质其实就是把用户的注册信息存到数据库，但是存入数据库的时候需要对其输入的密码进行加密防止数据库信息泄露时用户信息遭到暴露。具体就下面这么几个步骤：

1.  检查用户名是否已存在
2.  对密码进行加密处理
3.  创建新用户，存入数据库
4.  返回信息

这时候我们需要用到 bcrypt 这个依赖，它是用来给密码进行散列加密的，然后在登录的时候我们还会需要它来进行解密

```js
// controllers/authController.js
const User = require("../models/User");
const bcrypt = require("bcrypt");

async function register(req, res) {
  const { username, password, nickname } = req.body;

  try {
    // 检查用户名是否已存在
    const existingUser = await User.findOne({ where: { username } });
    if (existingUser) {
      return res.status(400).json({ msg: "Username already exists" });
    }

    // 对密码进行加密处理
    const hashedPassword = await bcrypt.hash(password, 10);

    // 创建新用户
    await User.create({ username, password: hashedPassword, nickname });

    res.status(201).json({ msg: "User registered successfully" });
  } catch (error) {
    res.status(500).json({ msg: "Failed to register user" });
  }
}

module.exports = { register };
```

### 登录

登录的过程其实就是校验用户的账号密码是否能在数据库中匹配出来，同时要对密码进行解密匹配。流程是这样的：

1.  看用户是否存在
2.  看密码是否匹配
3.  更新最后的登录时间
4.  创建 token
5.  下发用户信息和 token

```js
async function login(req, res) {
  const { username, password } = req.body;

  try {
    // 检查用户名是否存在
    const user = await User.findOne({ where: { username } });
    if (!user) {
      return res.status(401).json({ msg: "Invalid username or password" });
    }

    // 检查密码是否匹配
    const isPasswordMatch = await bcrypt.compare(password, user.password);
    if (!isPasswordMatch) {
      return res.status(401).json({ msg: "Invalid username or password" });
    }

    // 更新用户的最后在线时间
    user.lastOnlineTime = new Date();
    await user.save();

    // 创建 token 访问令牌
    const token = jwt.sign({ userId: user.id }, "xxx-your-secret-key", {
      expiresIn: "24h",
    });

    // 返回包含令牌、账号名和用户名的响应
    res.json({ token, account: user.username, nickname: user.nickname, userId: user.id});
  } catch (error) {
    res.status(500).json({ msg: "Failed to log in" });
  }
}

module.exports = { register, login };
```

现在我们的两个登录注册接口都编写完成了，接下来就要启动数据库去做接口验证了

## 启动数据库

耶斯，到这里我们就写完了我们的第一个接口。接下来要做的事情就是把数据库和服务给启动起来。这里我们使用 Docker 来进行 Mysql 的启动。如果你电脑上没安装 Docker，[可以去它的官网安装一下](https://www.docker.com/)，安装好之后在控制台输入 `docker -v` 有响应说明安装成功了

    docker -v
    Docker version 20.10.13, build a224086

安装好 Docker 之后，然后我们来安装一下 Mysql 镜像。来输入下面这条命令：

    docker run -d -p 3306:3306 -v D:/docker-mysql:/var/lib/mysql -e MYSQL_ROOT_PASSWORD=123456 --name mysql-container mysql:5.7

然后解释下这条命令的意思

*   拉取5.7版本的 Mysql 镜像

*   将容器内3306端口号映射到宿主机的3306端口

*   将容器内的数据挂载到我Windows电脑上的 D 盘 docker-mysql 目录中

*   初始化设置账号为 root ，密码为123456

*   容器名称设置为 mysql-container

接下来在控制台输入下面这条命令，查看所有容器列表，里面能看到我们的 mysql 容器就说明启动成功了，接下来就可以去连接数据库了

    docker ps

![image-20230608005823392](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/8ac98ddf80634256b8ce1040ac9bf260~tplv-k3u1fbpfcp-zoom-1.image)

后续如果想方便的管理容器，可以下载一个 [Docker Desktop](https://www.docker.com/products/docker-desktop/) 工具，它也是跨平台的，可以去其官网下载

## 连接数据库

别忘了我们在上一章中还没连接数据库呢，接下来我们去填一下连接数据库的参数，填写完对应的信息后，我们就能把服务给启动起来了

```js
// config/database.js

const { Sequelize } = require("sequelize");

const sequelize = new Sequelize(
  // 定义库名
  "express-blog",
  // 账号
  "root",
  // 密码
  "123456",
  {
    host: "localhost",
    dialect: "mysql",
  }
);

module.exports = sequelize;
```

到了这里之后，我们完成了前置条件：

*   定义数据模型

*   编写接口 localhost:3000/auth/register

*   启动数据库

然后我们现在可以通过 `npm run start` 把服务给启动起来了，然后发送个注册请求去试试看。

## 发送请求

这里推荐两个工具：

*   Postman：发送请求的软件，我这里用的是这个
*   Thunder Client：这个是 VSCode 插件，直接在插件商店里搜索就可以，使用起来也很方便，看个人喜好选择

然后可以看到下面我们成功发送了注册请求

![image-20230609214601529](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/364e7449bbb2471f9d43f451563d2cce~tplv-k3u1fbpfcp-zoom-1.image)

然后我们看下数据库，也看到已经存入了这条数据，说明这接口没问题了\~，接下来我们再去验证下登录接口，完成 token 的下发

![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/03e2099637e64b1e90b65fe2e5457517~tplv-k3u1fbpfcp-watermark.image?)

接下来我们进行登录接口的请求，可以看到其正确的返回了用户的账号名、昵称、token、用户ID，那说明这个接口也通过了，至于异常情况，大家可以自己试一试~~
![image.png](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/38bc8b01a4694c5d9c1a1b35ae0b406d~tplv-k3u1fbpfcp-watermark.image?)

## 小结

恭喜你，到这里就更进一步了\~ 这一章我们主要完成了登录和注册接口的编写、数据库接入、接口调试的工作，然后下一章中我们会去编写文件上传的接口以及为其加上 token 的鉴权\~ 

如果想要实时收到文章的更新，欢迎关注公众号《泡芙学前端》，同步更新文章中\~
