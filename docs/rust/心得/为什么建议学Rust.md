# 为什么我建议学 Rust？

## 前言

Rust 可能有点难学，但我还是建议去学一学，起码要了解一下它的理念，它是如何做到它所吹的那些特性的，为什么别的语言做不到它做到了，通过学习 Rust 也有可能会改变你之前的一些也许不那么正确的编程方式。哎，也许你会说我平时业务都做不完了，还学这么个破玩意干嘛，工作归工作，生活归生活嘛，但是作为一个有点追求的程序员，起码要学习一门底层系统语言吧，可以开拓自己的视野，跳出自己的一亩三分地也不错啊，啥，你说你不想学这些？ 那你写代码就是为了混口饭吃，那没事，了解了解也总行吧，不然也不知道为什么别人天天在那说这个东西。

当然你去学 C/C++ 也可以，当你使用 C++踩了一些坑后再来看 Rust ，也许你就知道 Rust 为什么要做一些限制你在代码里张牙舞爪的事情了。

## 社区状况

由 Mozilla 开发的 Rust 在过去几年中已经获得了主流使用。根据 StackOverflow 的 2023 年开发者调查，Rust 连续第 8 年被评为最受开发者喜爱的语言和开发者最想学习的语言，作为一种注重安全、速度和并发的系统编程语言，Rust 可以和 C++媲美性能，但具有现代语言(如 Python 或 JavaScript)的人体工程学。目前在许多大公司内部都有使用，比如国内字节、华为、VIVO、国外微软、谷歌、亚马逊、DropBox、Cloudflare 等，之前的文章也提到过这些。

废话不多说了，直接说下 Rust 的相关特性吧。

## 官方说辞

首先，官方鼓吹的它有以下的一些优点：

- 高性能 API 服务器、分布式系统、高性能机器学习模型、数据科学应用
- 跨平台桌面应用程序和命令行工具
- 零成本抽象，Rust 提供不牺牲性能的高水平人体工程学(说人话就是优雅)
- 保证内存安全，Rust 的严格编译器在编译时可以防止空指针异常，数据竞争等等
- 无畏并发，Rust 的类型系统和所有权模式可以保证线程安全
- 健壮的生态系统，Rust 有一个在蓬勃发展的社区

## 速度与激情

Rust 是高性能的语言，拥有和 C/C++相当的性能。那么它是通过什么来实现这一点的呢？

### 零成本抽象

Rust 在不牺牲性能的情况下提供抽象。比如，Rust 有可以编译成 for 循环的迭代器并且没有性能损失。这意味着可以在不牺牲速度的情况下编写干净的代码，比如下面这段代码，比你自己手写一个 for 循环并相加要简洁得多：

```rust
let v = vec![1, 2, 3];
let sum = v.iter().sum(); // 这会编译为 for 循环
```

口号就是 "高级语句别怕慢，编译之后都一样"

### 移动语义

Rust 具有移动语义，这意味着值的所有权会在作用域之间进行移动，这可以避免开销比较高的数据复制，比如:

```rust
let x = vec![1, 2, 3];
let y = x; // `x` 在这里被移动，并且不能再使用
```

这里，向量数组被移动到 y 中，而不是复制。注意复制是指数据从一个地方的内存到另一个地方的内存，而移动指的是数据内存没发生改变，只是指向变了。

### 没垃圾回收

Rust 通过所有权和借用规则提供内存安全，而不是垃圾收集器。这避免了运行时进行垃圾回收的性能损失，可以避免在 JS/Java/Go 等语言里"Stop the world"的情况发生。代码可以在编译时静态保证没有使用后释放错误、悬空指针或数据竞争。

> "Stop the world" 意味着在进行垃圾回收时，程序的执行会被短暂暂停以进行内存回收

### 非常小的运行时

Rust 的运行时非常小，不需要运行时类型信息、虚拟机或垃圾收集器，这就能打包出开销很小的二进制文件，不过有一些场景也是需要用到运行时的，比如动态分发(现在不需要了解，用于在运行时根据传入类型确定调用方法的一种手段)。

## 安全可靠

Rust 是主打安全的语言，在编译时可以防止一些内存上的错误，这是通过 Rust 严格的借用和所有权规则来实现的。
所有权和借用是 Rust 最特殊和最有用的两个概念。所有权意味着 Rust 中的每个值都有一个拥有它的变量，值的所有者负责释放与之关联的资源，当所有者超出范围时，拥有的值将被删除。

当对一个值有不可变或可变的引用时，就会发生借用。对于不可变引用，原始所有者仍然拥有该值，但是借方可以读取它。使用可变引用，借方可以改变值。但是，可变和不可变借用不能共存，并且借用必须在所有者超出作用域范围之前结束。

上面这里有点绕，但是只要记住："可变不共享，共享不可变，结束前要还" 这句就行了。下面看 2 个例子：

可变不共享，共享不可变

```rust
fn main() {
    let mut x = 5;
    let y = &x; // y 从 x 借用一个不可变引用
    let z = &mut x; // y 从 x 借用一个可变借用。报错，不能在一个作用域内同时出现可变借用和不可变借用
}
```

结束前要还

```rust
fn main() {
    let mut x = 5; // x 是可变的，拥有值 5
    let y = &mut x; // y 从 x 借用到一个可变引用

    *y += 1; // 通过 y 来增加 x 的值，因为 y 是对 x 的可变引用
    println!("x is {}", x); // 打印出了 6
} // y 超出了作用域，结束对 x 的引用
```

## 无畏并发

Rust 为并发代码提供了内置支持，这允许 Rust 程序充分利用多核。由于 Rust 的所有权和类型系统，在 Rust 中不可能在编译时出现数据竞争，这就是所谓的“无畏并发”。

### 多线程

```rust
use std::thread;

fn main() {
    thread::spawn(|| {
        println!("Hello new thread!");
    });
}
```

这会从新的线程里打印“Hello new thread!”，它是和主线程并行的。

### 线程通信

通道可以让消息在线程之间进行传递

```rust
use std::thread;

use crossbeam::channel;

fn main() {
    let (tx, rx) = channel::unbounded();

    thread::spawn(move || {
        tx.send("Hello from thread!").unwrap();
    });

    let msg = rx.recv().unwrap();
    println!("Got message: {}", msg); // Got message: Hello from thread!
}
```

这里我们创建了一个不限制大小的通道并生成一个新的线程，该线程在通道上发送消息，在主线程中接收消息并打印它。

### 共享状态

虽然通道对于消息传递很有用，但有时线程需要访问共享的状态。这可以通过互斥锁来锁定对临界区的访问，这个程序生成 10 个线程，每个线程增加一个共享计数器。通过使用互斥锁，可以确保一次只有一个线程可以访问计数器增加的临界区。

```rust
use std::{
    sync::{Arc, Mutex},
    thread,
};

fn main() {
    let counter = Arc::new(Mutex::new(0));
    let counters = vec![counter.clone(); 10];

    for counter in &counters {
        let counter = counter.clone();
        thread::spawn(move || {
            let mut num = counter.lock().unwrap();
            *num += 1;
        });
    }

    for counter in &counters {
        let num = counter.lock().unwrap();
        println!("{}", *num);
    }
}
```

在 C/C++ 中实现并发可要小心翼翼，一不小心就出内存问题了。

## 完善的工具链

Rust 有一套很好用的工具生态，比 C/C++ 的都要完善，比如：

- Cargo：类似于 NPM 的 Rust 包管理器和构建工具
- Rustup：有点类似于 nvm，用来管理 Rust 版本(稳定版，测试版，夜间版)。
- Rustfmt：类似于 Prettier，代码风格格式化
- Clippy：类似于 ESLint，Rust 的静态代码分析工具

## 总结

Rust 是一种现代编程语言，它提供了速度、安全性和并发性。Rust 通过零成本抽象、移动语义、保证内存安全以及最小的运行时实现了与 C 和 C++相当的性能。Rust 编译器严格执行关于所有权、借用和生命周期的规则，可以防止各种错误如悬空指针、使用后释放错误和数据竞争等问题。此外，Rust 还对并发性和并行性有很好的支持，编译器会在编译时防止数据竞争，这可以让你写并发代码时更加从心。

我是一个搞前端的，也在学 Rust。不管怎样，通过学 Rust 还是能够获得比前端这个领域里更多的东西，学一学总没错，实在不行你来了解一下也行嘛。
