## 读书记录

### 所有权和移动

需要了解 Copy 和 Clone 的区别，以及了解所有权的移动。

所有权的移动 1 比.0 如

```rust
let a = "a".to_string();
let b = a;
```

a 的值的所有权会移动到 b，a 会变成未初始化的状态。

标准的 Copy 类型包括所有机器整数类型、浮点数类型、char、bool 类型，以及 Copy 类型的元组或固定大小的数组。
String、Box 不是 Copy 类型，因为它们拥有堆中的内存，File 类型不是 Copy 类型，因为它需要向操作系统申请文件句柄，MutexGuard 表示一个互斥锁，它最终需要释放锁，所以任何在丢弃值需要做一些特殊操作的类型都不是 Copy 类型。

对于 Struct 结构体，如果里面的所有类型都是 Copy 类型，那么可以通过 #[derive(Copy,Clone)] 属性放在结构体上面，就可以让这个结构体变为 Copy 类型，但如果结构体里面只要有一个不是 Copy 类型，那么这样做就会编译报错。

如果想要像 Python 一样赋值时增加引用计数，而不是发生移动，可以使用 Rc(非线程安全)/Arc(线程安全)，它是引用计数智能指针，它本身拥有的值不可变。

记住一句话：在 Rust 中的值，共享不可变，可变不共享。

### 引用
