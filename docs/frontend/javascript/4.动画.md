## 前端动画基础篇

要认识前端动画，我们可以先来了解一些我们常用的动画概念。

有一个我们经常用可能又不太熟悉的东西，比如在 CSS 里面我们写 animation 或者 transition 动画的时候经常用的属性： linear、ease、ease-in、ease-out、ease-in-out， 这些都分别是个什么意思？

想要了解这些那首先就要了解一下贝塞尔曲线了

### 贝塞尔曲线基础概念

贝塞尔经常被用于绘制计算机图形以及各种动画，用贝塞尔曲线绘制的动画可以很平滑，给到用户一种舒适感。

贝塞尔曲线由控制点来进行定义，通常由两个及以上的点来构成一个贝塞尔曲线。

比如有两个控制点的时候：

![image-20230709103337379](https://cdn.jsdelivr.net/gh/PuffMeow/PictureSave/doc/image-20230709103337379.png)

三个控制点的时候：

![image-20230709103407388](https://cdn.jsdelivr.net/gh/PuffMeow/PictureSave/doc/image-20230709103407388.png)

四个控制点的时候：

![image-20230709103429642](https://cdn.jsdelivr.net/gh/PuffMeow/PictureSave/doc/image-20230709103429642.png)

观察这些曲线，我们能够发现一个现象：

- 控制点不总是在曲线上
- 曲线顺序等于控制点数减一
- 曲线总是在控制点围成的图形内

当我们想要改变贝塞尔曲线的时候，可以去改变控制点的位置，比如这样：

![1](https://cdn.jsdelivr.net/gh/PuffMeow/PictureSave/doc/1.gif)

像上面这个图，最后我们可以生成一个 cubic-bezier(0,1,1,0) 这样的贝塞尔曲线，

它的动画表现：先快速加速，然后停止，然后再加速直到停止，以一个小球从左到右运动为例就是这样子的：

![3](https://cdn.jsdelivr.net/gh/PuffMeow/PictureSave/doc/3.gif)

另外贝塞尔曲线的运动是可以超出它本身的位置的，比如这个曲线，它会先向后运动，再开始加速到超出右边位置，最后再回到终点本身的位置：

![image-20230709160211583](https://cdn.jsdelivr.net/gh/PuffMeow/PictureSave/doc/image-20230709160211583.png)

动画表现是这样的：

![3333](https://cdn.jsdelivr.net/gh/PuffMeow/PictureSave/doc/3333.gif)

生成上面贝塞尔曲线的网站：https://cubic-bezier.com，大家可以来这里自行调试。

### 贝塞尔曲线高级概念

贝塞尔曲线的生成使用了 De Casteljau (德卡斯特里奥) 这个算法，[维基百科上的解释](https://en.wikipedia.org/wiki/De_Casteljau%27s_algorithm)

`DeCasteljau` 函数接受一个包含贝塞尔曲线控制点的数组 `points` 和参数 `t`。通过递归将相邻的控制点进行插值，最终计算出贝塞尔曲线上指定参数 `t` 处的点坐标。

这个算法的 JavaScript 实现：

```js
function deCasteljau(points, t) {
  if (points.length === 1) {
    return points[0];
  }

  const newPoints = [];
  for (let i = 0; i < points.length - 1; i++) {
    const p0 = points[i];
    const p1 = points[i + 1];

    const x = (1 - t) * p0[0] + t * p1[0];
    const y = (1 - t) * p0[1] + t * p1[1];
    newPoints.push([x, y]);
  }

  return deCasteljau(newPoints, t);
}
```

对于这个算法的解释：

比如我们有一个宽高都为 1 的矩形，把它看做一个坐标系，原点是(0,0)，终点是(0,1)，另外两个控制点分别为(0,1)和(1,0)，此时假如我们的 t 是 0.5，那么就可以这个矩形最中间点 (0.5,0.5) 的坐标。比如下方这个图

![image-20230709173323321](https://cdn.jsdelivr.net/gh/PuffMeow/PictureSave/doc/image-20230709173323321.png)

当我们把 t 从 0 -> 1 位置不断计算并绘制，那么就可以得出一条贝塞尔曲线了。

我们来写一个示例 demo，来实现这样的一个绘制效果，

它的控制点有 4 个，分别是我们上面提到的那 4 个点

```js
const controlPoints = [
  [0, 0], // 起点
  [0, 1], // 控制点1
  [1, 0], // 控制点2
  [1, 1], // 终点
];
```

![ggg](https://cdn.jsdelivr.net/gh/PuffMeow/PictureSave/doc/ggg.gif)

实现的代码：

```js
<!DOCTYPE html>
<html>
  <head>
    <title>Bezier Curve Demo</title>
    <style>
      canvas {
        border: 1px solid black;
      }
    </style>
  </head>
  <body>
    <canvas id="canvas" width="500" height="500"></canvas>

    <script>
      const controlPoints = [
        [0, 0], // 起点
        [0, 1], // 控制点1
        [1, 0], // 控制点2
        [1, 1], // 终点
      ];

      // 在页面加载完成后执行绘制函数
      window.onload = function () {
        const canvas = document.getElementById("canvas");
        const ctx = canvas.getContext("2d");

        // 将 y 轴反转，让左下角的位置变为原点
        ctx.transform(1, 0, 0, -1, 0, canvas.height);

        drawBezierCurve(ctx);
      };

	  // 绘制贝塞尔曲线，我们的画布是 500 * 500 的，所以要做一些额外处理
      function drawBezierCurve(ctx) {
        for (let i = 0; i < 500; i++) {
          setTimeout(() => {
            const [x, y] = deCasteljau(controlPoints, i / 500);
            drawPoint(ctx, x * 500, y * 500);
          }, 10 * i);
        }
      }

      // 绘制点，传入点的 x 和 y 坐标
      function drawPoint(ctx, x, y) {
        ctx.beginPath();
        ctx.arc(x, y, 2, 0, 360 * (Math.PI / 180));
        ctx.closePath();

        ctx.stroke();
      }

      // 德卡斯特里奥算法
      function deCasteljau(points, t) {
        if (points.length === 1) {
          return points[0];
        }

        const newPoints = [];
        for (let i = 0; i < points.length - 1; i++) {
          const p0 = points[i];
          const p1 = points[i + 1];
          const x = (1 - t) * p0[0] + t * p1[0];
          const y = (1 - t) * p0[1] + t * p1[1];
          newPoints.push([x, y]);
        }

        return deCasteljau(newPoints, t);
      }
    </script>
  </body>
</html>
```

接下来为了加深我们对这个算法的理解，我们再来让看下这个贝塞尔曲线上的点是如何被找到的，以下面这张图为例，我们把相邻的点给一一连接起来，比如这个数组：

```js
const controlPoints = [
  [0, 0], // 起点
  [0, 1], // 控制点1
  [1, 0], // 控制点2
  [1, 1], // 终点
];
```

我们把 (0, 0) -> (0, 1) 连接起来，把 (0, 1) -> (1, 0) 连接起来， 最后把 (1, 0) -> (1, 1) 连接起来，然后就可以得到下面这个图，看红线部分。

![image-20230709193759476](https://cdn.jsdelivr.net/gh/PuffMeow/PictureSave/doc/image-20230709193759476.png)

那么连接起来之后，有啥用呢？

问得好，这些线可以辅助我们找到贝塞尔曲线上的点。下面我们先来个简单的，我们将分析过程一步一步拆解来看。

我们就以 t = 0.25 的时候来分析，也就是 1/4 。

- 分别找到 (0, 0) -> (0, 1)、(0, 1) -> (1, 0) 、 (1, 0) -> (1, 1) 这三根线段的 1/4 处

  ![image-20230709194654909](https://cdn.jsdelivr.net/gh/PuffMeow/PictureSave/doc/image-20230709194654909.png)

- 接下来把这三个 1/4 处的点一一连接起来

  ![image-20230709195423044](https://cdn.jsdelivr.net/gh/PuffMeow/PictureSave/doc/image-20230709195423044.png)

- 向上面一样，接下来再找到我们新连接的两根线的 1/4 处，并且把它们连接起来

  ![image-20230709195852034](https://cdn.jsdelivr.net/gh/PuffMeow/PictureSave/doc/image-20230709195852034.png)

- 最后，再找到我们最后连接的这根线的 1/4 处，那么这个点，就是它在贝塞尔曲线上的位置

  ![image-20230709200045235](https://cdn.jsdelivr.net/gh/PuffMeow/PictureSave/doc/image-20230709200045235.png)

最后，为了让我们加深理解，这里再看一张动图来领会这个过程

![哈哈哈](https://cdn.jsdelivr.net/gh/PuffMeow/PictureSave/doc/%E5%93%88%E5%93%88%E5%93%88.gif)

比如 t = 0.75 的时候，图就是这样子的了，可以看到两根绿色的线和蓝色的线，它们的位置都处在了 3/4 处，那么蓝色线 3/4 处的点就是它在贝塞尔曲线上的点。

![image-20230709200825018](https://cdn.jsdelivr.net/gh/PuffMeow/PictureSave/doc/image-20230709200825018.png)

那么到这里你理解这个算法的计算过程了吗？

### 小结一下

De Casteljau 算法是一个递归的算法，它可以构造任意阶数的贝塞尔曲线，但是实践中我们一般都不会使用超过立方阶的贝塞尔曲线。

现在再回到开头我们说的 ease、ease-in、ease-out、ease-in-out 这几个属性，其实它们本质上就是贝塞尔曲线。

cubic-bezier 这个函数的四个参数对应的是三次贝塞尔曲线的第二个和第三个控制点的坐标 (x1 ,y1, x2, y2)，因为第一个控制点固定为(0, 0)，第四个控制点坐标固定为(1,1)，x1, x2 必须要在 [0, 1] 范围。

ease：`cubic-bezier(0.25, 0.1, 0.25, 1.0)`

ease-in：`cubic-bezier(0.42, 0.0, 1.0, 1.0)`

ease-out：`cubic-bezier(0.0, 0.0, 0.58, 1.0)`

ease-in-out：`cubic-bezier(0.42, 0.0, 0.58, 1.0)`

下面是它们对应的贝塞尔曲线图(图片来自 MDN)，如果要看实际的一个表现效果，可以去上面我给的那个网站中.

![image-20230709202649399](https://cdn.jsdelivr.net/gh/PuffMeow/PictureSave/doc/image-20230709202649399.png)

最后这里给几个贝塞尔曲线计算公式，不过一般的场景中很少用到，通过鼠标拖拽绘制的方式生成贝塞尔曲线就能完成大部分的需求了。

- 2 点曲线的公式：

  `P = (1-t)P1 + tP2`

- 对于 3 个控制点：

  `P = (1−t)^2P1 + 2(1−t)tP2 + t^2P3`

- 对于 4 个控制点：

- P = `(1−t)^3P1 + 3(1−t)^2tP2 +3(1−t)t^2P3 + t^3P4`

其它更多的贝塞尔曲线可以参考这个网站:

https://easings.net/zh-cn#

## 前端动画实战篇

首先说明，大部分的动画都可以使用纯 CSS3 来完成，但是我们这里主要还是讲怎么以 JS 来实现一些常见的动画，并温习上面我们学到的知识。关于 CSS3 和 JS 动画之间，如果不需要一些自定义事件之类的动画能用 CSS3 动画实现就使用 CSS3，否则就使用 JS 实现，因为 JS 的定制化程度会更高。

我们先来封装一个基础的通用动画函数，它提供了自定义绘制和自定义动画过渡的能力。

封装完成之后我们就以这个函数来实现一些业务需求中很常见的功能

```js
interface IAnimateOptions {
  /** 动画运行的总毫秒数 */
  duration?: number;
  /** 动画执行结束 */
  onEnd?: () => void;
  /** 计算动画进度的函数。获取从 0 到 1 的小数时间。可以理解为坐标系中的 x 轴 */
  timing: (timeFraction: number) => number;
  /** 绘制动画的函数 */
  onDraw: (progress: number) => void;
}

export function animate({
  timing,
  duration = 1000,
  onDraw,
  onEnd,
}: IAnimateOptions) {
  const start = performance.now();

  /** 确保一个值在给定的最小值和最大值之间，如果超出范围，则返回最小值或最大值 */
  const minMax = (val: number, min: number, max: number) =>
    Math.min(Math.max(val, min), max);

  requestAnimationFrame(function animate(time: number) {
    // timeFraction 从 0 增加到 1
    const timeFraction = minMax((time - start) / duration, 0, 1);
    // 计算当前动画状态
    const progress = timing(timeFraction);

    onDraw(progress);

    if (timeFraction < 1) {
      requestAnimationFrame(animate);
    } else {
      onEnd?.();
    }
  });
}
```

### 数字滚动

我们基于上面的这个函数来实现一个数字滚动的 React 组件

首先我们来看下线性执行的一个效果，可以看到动画没任何的过渡效果

![33333](https://cdn.jsdelivr.net/gh/PuffMeow/PictureSave/doc/33333.gif)

```js
import { useEffect, useRef } from "react";
import { animate } from "./Animate";

const Bezier = () => {
  const numberRef = useRef<HTMLDivElement>(null);

  useEffect(() => {
    const startVal = 0;
    const endVal = 9999.99;

    const diff = endVal - startVal;

    animate({
      duration: 3000,
      // 线性渐变
      timing: (t) => t,
      onDraw: (progress) => {
        const currentValue = startVal + diff * progress;
        numberRef.current!.textContent = currentValue.toFixed(2);
      },
      onEnd: () => {
        console.log("end");
      },
    });
  }, []);

  return <div ref={numberRef}></div>;
};
```

接下来我们尝试着给这个数字滚动加一点过渡效果，那么我们就要去改一下贝塞尔曲线函数了，我们去这个网站里面去搞一个带结束平滑过渡的贝塞尔曲线来，https://easings.net/zh-cn#，就决定是你了，接下来我们把它里面的函数搞出来看看效果

![image-20230711230223216](https://cdn.jsdelivr.net/gh/PuffMeow/PictureSave/doc/image-20230711230223216.png)

```js
animate({
  // 把时间延长一点
  duration: 5000,
  timing: (t) => 1 - Math.pow(1 - t, 5),
});
```

从这个执行效果可以看到确实是和上面那条贝塞尔曲线相符，后面带上了一个缓慢结束的拖尾效果

![hahahahaha](https://cdn.jsdelivr.net/gh/PuffMeow/PictureSave/doc/hahahahaha.gif)

其它更多的贝塞尔曲线效果就交由大家自己去尝试了，接下来我们再看另一个常见的业务场景

### 轮盘

![lotteryWheel](https://cdn.jsdelivr.net/gh/PuffMeow/PictureSave/doc/lotteryWheel.gif)

```jsx
import { useEffect, useRef } from "react";
import { animate } from "./Animate";
import styles from "./index.module.less";

const Bezier = () => {
  const lotteryWheelRef = useRef<HTMLDivElement>(null);
  // 分成 10 个格子
  const itemNum = 10;

  useEffect(() => {
    // 8 秒转 8 圈
    animate({
      duration: 8000,
      // 找一个平滑结束的贝塞尔曲线函数
      timing: (t) => Math.sqrt(1 - Math.pow(t - 1, 2)),
      onDraw: (progress) => {
        lotteryWheelRef.current!.style.transform = `rotate(${
          progress * 360 * 8
        }deg)`;
      },
    });
  }, []);

  return (
    <div ref={lotteryWheelRef} className={styles.lotteryWheel}>
      {new Array(itemNum).fill({}).map((_, index) => {
        return (
          <div
            key={index}
            className={styles.line}
            style={{
              transform: `rotate(${(360 / itemNum) * index}deg)`,
            }}
          ></div>
        );
      })}
    </div>
  );
};

// index.module.less
.lotteryWheel {
  width: 100px;
  height: 100px;
  border-radius: 50%;
  background: pink;
  border: 1px solid #666;
  position: relative;
}

.line {
  position: absolute;
  width: 1px;
  height: 50px;
  left: 50%;
  transform: translateX(-50%);
  transform-origin: 0.5px 50px;
  top: 0;
  background: #666;
}
```
