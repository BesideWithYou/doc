# 实现一个队列

```rust
/// 队列
/// 以 Vec 的尾部为队头，头部为队尾，这样入队的时候时间复杂度为 O(n)，出队的时间复杂度为 O(1)
#[derive(Debug)]
struct Queue<T> {
    // 最大容量
    capacity: usize,
    // 数据容器
    data: Vec<T>,
}

impl<T> Queue<T> {
    fn new(capacity: usize) -> Self {
        Self {
            capacity,
            data: vec![],
        }
    }

    fn size(&self) -> usize {
        self.data.len()
    }

    fn is_empty(&self) -> bool {
        self.capacity == 0
    }

    fn enqueue(&mut self, value: T) -> Result<(), String> {
        if Self::size(&self) >= self.capacity {
            return Err("Queue capacity exceeded".to_string());
        }

        self.data.insert(0, value);

        Ok(())
    }

    fn dequeue(&mut self) -> Option<T> {
        if self.is_empty() {
            return None;
        }

        return self.data.pop();
    }
}

fn main() {
    let mut queue = Queue::new(3);

    queue.enqueue(1).unwrap();
    queue.enqueue(2).unwrap();
    queue.enqueue(3).unwrap();
    // 打印 3
    println!("{}", queue.size());

    if let Err(err) = queue.enqueue(4) {
        // 打印 Queue capacity exceeded， 容量超出了 3
        println!("{}", err)
    }

    queue.dequeue();
    // 出队一个，打印 2
    println!("{}", queue.size());

    // 打印 Queue { capacity: 3, data: [3, 2] }
    println!("{:?}", queue);
}
```
