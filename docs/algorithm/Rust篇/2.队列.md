# 实现一个队列

```rust
/// 队列
/// 以 Vec 的右侧为队头，左侧为队尾，这样入队的时候时间复杂度为 O(n)，出队的时间复杂度为 O(1)
#[derive(Debug)]
struct Queue<T> {
    // 最大容量
    capacity: usize,
    // 数据容器
    data: Vec<T>,
}

/// 实现队列
impl<T> Queue<T> {
    fn new(capacity: usize) -> Self {
        Self {
            capacity,
            data: Vec::with_capacity(capacity),
        }
    }

    /// 返回队列长度
    fn size(&self) -> usize {
        self.data.len()
    }

    /// 队列是否为空
    fn is_empty(&self) -> bool {
        self.capacity == 0
    }

    /// Vec右侧为队头，入队
    fn enqueue(&mut self, value: T) -> Result<(), String> {
        if self.size() >= self.capacity {
            return Err("capacity exceeded".to_string());
        }

        self.data.insert(0, value);

        Ok(())
    }

    // Vec 右侧为队头，出队
    fn dequeue(&mut self) -> Option<T> {
        if self.is_empty() {
            return None;
        }

        return self.data.pop();
    }
}

fn main() {
    let mut queue = Queue::new(3);

    // 入队3个值
    queue.enqueue(1);
    queue.enqueue(2);
    queue.enqueue(3);

    // 打印 3
    println!("{}", queue.size());

    if let Err(err) = queue.enqueue(4) {
        // 打印 Queue capacity exceeded， 容量超出了 3
        println!("{}", err)
    }

    queue.dequeue();
    // 出队一个，打印 2
    println!("{}", queue.size());

    // 打印 Queue { capacity: 3, data: [3, 2] }
    println!("{:?}", queue);
}
```
