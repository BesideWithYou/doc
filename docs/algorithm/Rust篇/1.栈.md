# 实现一个栈

```rust
/// 栈
fn main() {
    let mut stack = Stack::new();
    stack.push(1);
    stack.push(2);
    // 打印 Some(2)
    println!("{:?}", stack.peek());
    stack.pop();
    // 打印 Some(1)
    println!("{:?}", stack.peek());

    // 修改第一个值为 111
    stack.get_mut(0).map(|node| *node = 111);
    // 打印 Some(111)
    println!("{:?}", stack.get(0));
}

#[derive(Debug)]
struct Stack<T> {
    size: usize,
    data: Vec<T>,
}

impl<T> Stack<T> {
    fn new() -> Stack<T> {
        Self {
            // 当前长度
            size: 0,
            // 数据容器
            data: vec![],
        }
    }

    // 往栈中推进一个值
    fn push(&mut self, value: T) {
        self.data.push(value);
        self.size += 1;
    }

    // 出栈
    fn pop(&mut self) -> Option<T> {
        if self.size == 0 {
            return None;
        }

        self.size -= 1;
        self.data.pop()
    }

    // 查看栈顶元素
    fn peek(&self) -> Option<&T> {
        if self.size == 0 {
            return None;
        }

        self.data.get(self.size - 1)
    }

    // 根据下标获取对应位置数据的不可变引用
    fn get(&self, index: usize) -> Option<&T> {
        if self.size == 0 {
            return None;
        }

        self.data.get(index)
    }

    // 根据下标获取对应位置数据的可变引用
    fn get_mut(&mut self, index: usize) -> Option<&mut T> {
        if self.size == 0 {
            return None;
        }

        self.data.get_mut(index)
    }

    // 移除一个值
    fn remove(&mut self, index: usize) -> Option<T> {
        if index >= self.size {
            return None;
        }

        Some(self.data.remove(index))
    }

    // 判断栈是否为空
    fn is_empty(&self) -> bool {
        self.size == 0
    }

    // 获取栈的长度
    fn size(&self) -> usize {
        self.size
    }
}

```
