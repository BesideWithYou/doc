## 1.实现一个栈

```rust
/// 栈
#[derive(Debug)]
struct Stack<T> {
    size: usize,
    data: Vec<T>,
}

impl<T> Stack<T> {
    fn new() -> Self {
        Self {
            // 当前长度
            size: 0, 
            // 数据容器
            data: vec![],
        }
    }

    fn push(&mut self, value: T) {
        self.data.push(value);
        self.size += 1;
    }

    fn pop(&mut self) -> Option<T> {
        if self.size == 0 {
            return None;
        }

        self.size -= 1;
        self.data.pop()
    }

    fn peek(&self) -> Option<&T> {
        if self.size == 0 {
            return None;
        }

        self.data.get(self.size - 1)
    }

    fn is_empty(&self) -> bool {
        self.size == 0
    }

    fn size(&self) -> usize {
        self.size
    }
}

fn main() {
    let mut stack = Stack::new();
    stack.push(1);
    stack.push(2);
    // 打印 2
    println!("{:#?}", stack.peek().unwrap());
    stack.pop();
    // 打印 1
    println!("{:#?}", stack.peek().unwrap());
}
```

## 2.实现一个队列

```rust
/// 队列
/// 以 Vec 的尾部为队头，头部为队尾，这样入队的时候时间复杂度为 O(n)，出队的时间复杂度为 O(1)
#[derive(Debug)]
struct Queue<T> {
    // 最大容量
    capacity: usize,
    // 数据容器
    data: Vec<T>,
}

impl<T> Queue<T> {
    fn new(capacity: usize) -> Self {
        Self {
            capacity,
            data: vec![],
        }
    }

    fn size(&self) -> usize {
        self.data.len()
    }

    fn is_empty(&self) -> bool {
        self.capacity == 0
    }

    fn enqueue(&mut self, value: T) -> Result<(), String> {
        if Self::size(&self) >= self.capacity {
            return Err("Queue capacity exceeded".to_string());
        }

        self.data.insert(0, value);

        Ok(())
    }

    fn dequeue(&mut self) -> Option<T> {
        if self.is_empty() {
            return None;
        }

        return self.data.pop();
    }
}

fn main() {
    let mut queue = Queue::new(3);

    queue.enqueue(1).unwrap();
    queue.enqueue(2).unwrap();
    queue.enqueue(3).unwrap();
    // 打印 3
    println!("{}", queue.size());

    if let Err(err) = queue.enqueue(4) {
        // 打印 Queue capacity exceeded， 容量超出了 3
        println!("{}", err)
    }

    queue.dequeue();
    // 出队一个，打印 2
    println!("{}", queue.size());

    // 打印 Queue { capacity: 3, data: [3, 2] }
    println!("{:?}", queue);
}
```



