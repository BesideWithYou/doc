import{_ as s,o as a,c as n,Q as t}from"./chunks/framework.18ed7b43.js";const m=JSON.parse('{"title":"Rust 在前端都干了些啥？","description":"","frontmatter":{},"headers":[],"relativePath":"rust/心得/Rust在前端都干了些啥.md","filePath":"rust/心得/Rust在前端都干了些啥.md","lastUpdated":1693326569000}'),e={name:"rust/心得/Rust在前端都干了些啥.md"},o=t(`<h1 id="rust-在前端都干了些啥" tabindex="-1">Rust 在前端都干了些啥？ <a class="header-anchor" href="#rust-在前端都干了些啥" aria-label="Permalink to &quot;Rust 在前端都干了些啥？&quot;">​</a></h1><h2 id="前言" tabindex="-1">前言 <a class="header-anchor" href="#前言" aria-label="Permalink to &quot;前言&quot;">​</a></h2><p>这里有一篇两年前的文章：<a href="https://mp.weixin.qq.com/s?__biz=MzkxNDIzNTg4MA==&amp;mid=2247485792&amp;idx=1&amp;sn=682a4dee7ce4d3b47a81baf9ebd7a98a" target="_blank" rel="noreferrer">Rust 是 JavaScript 基础设施的未来</a>，应该还是有挺多人看到过的。当时在前端社区上还掀起了一阵 Rust 风，有人说怎么天天造轮子，有人说实在是学不动了，也有人抱着积极的心态去拥抱新东西。</p><p>那么现在两年已经过去了， Rust 在前端最近咋样了，它都干了些啥？</p><h2 id="目前用-rust-搞了哪些前端基建工具" tabindex="-1">目前用 Rust 搞了哪些前端基建工具 <a class="header-anchor" href="#目前用-rust-搞了哪些前端基建工具" aria-label="Permalink to &quot;目前用 Rust 搞了哪些前端基建工具&quot;">​</a></h2><p>虽然有一些工具开头的那篇文章中已经讲了，但我这里还是要简单说一下。</p><h3 id="swc" tabindex="-1"><a href="https://github.com/swc-project/swc" target="_blank" rel="noreferrer">SWC</a> <a class="header-anchor" href="#swc" aria-label="Permalink to &quot;[SWC](https://github.com/swc-project/swc)&quot;">​</a></h3><p>swc 是用 Rust 编写的超快 TypeScript/JavaScript 编译器。同时支持 Rust 和 JavaScript ，可以用于代替 Babel。</p><p>这里是官方给的性能对比数据： <a href="https://swc.rs/docs/benchmarks" target="_blank" rel="noreferrer">Benchmarks</a></p><p>结论是同步性能 swc 远超 Babel 和 esbuild，异步和多线程的性能 swc 和 esbuild 差不多，但都是远超 Babel 的。</p><p>这两年里面也越来越多的前端项目都使用 swc/esbuild 来代替 Babel 了。</p><h3 id="deno" tabindex="-1"><a href="https://github.com/denoland/deno" target="_blank" rel="noreferrer">Deno</a> <a class="header-anchor" href="#deno" aria-label="Permalink to &quot;[Deno](https://github.com/denoland/deno)&quot;">​</a></h3><p>还记得这玩意吗？最近没啥热度了。</p><p>当初刚出来的时候就说它主打安全、TypeScript 无需配置开箱即用，内置一整套完整工具链如代码格式化工具、测试工具、Bench 工具、打包工具等，库中心化管理等。</p><p>Node 之父也是 Deno 之父(Ryan Dahl) 说 Node.js 的依赖管理是个败笔，特别是它 node_modules，一开始搞的所有库都采用中心化管理，通过 Url 来进行引入，不支持 package.json。结果2022年8月就开始支持实验性引入 npm 包，23年正式发布了对 package.json 和 npm 的支持，自己啪啪打自己的脸，还发布了一篇文章解释为什么要支持 npm: <a href="https://deno.com/blog/package-json-support" target="_blank" rel="noreferrer">为什么我们添加 Deno 对 package.json 的支持</a>。大概的意思就是之前走的不兼容 npm 的路线导致社区上带来了很多声音，比如不能去复用 npm 生态，不支持运行老的 node 项目，自己搞一套标准放弃以前 node 积累的生态就是搬起石头砸自己的脚。</p><p>另外之前 Deno 载入远程包的时候会产生重复依赖的问题，比如同一个包的不同版本 &quot;<a href="https://deno.land/std@0.179.0/uuid/mod.ts" target="_blank" rel="noreferrer">https://deno.land/std@0.179.0/uuid/mod.ts</a>&quot; 和 <a href="https://deno.land/std@0.179.1/uuid/mod.ts%EF%BC%8C%E5%AE%83%E4%BB%AC%E6%98%AF%E5%87%A0%E4%B9%8E%E7%9B%B8%E5%90%8C%E7%9A%84%E4%BB%A3%E7%A0%81%EF%BC%8C%E4%BD%86%E6%98%AF%E5%AE%83%E4%BB%AC%E7%89%88%E6%9C%AC%E5%8F%B7%E9%83%BD%E5%87%BA%E7%8E%B0%E5%9C%A8%E4%BA%86%E6%A8%A1%E5%9D%97%E5%9B%BE%E4%B8%AD%E3%80%82" target="_blank" rel="noreferrer">https://deno.land/std@0.179.1/uuid/mod.ts，它们是几乎相同的代码，但是它们版本号都出现在了模块图中。</a></p><p>Deno 给出的一个现代化解决方案就是使用裸说明符来引入，比如在 deno.json 中通过这样的方式去同时支持引入 deno 三方包和 npm 三方包</p><div class="language-json vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">json</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#E1E4E8;">{</span></span>
<span class="line"><span style="color:#E1E4E8;">  </span><span style="color:#79B8FF;">&quot;imports&quot;</span><span style="color:#E1E4E8;">: {</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#79B8FF;">&quot;oak&quot;</span><span style="color:#E1E4E8;">: </span><span style="color:#9ECBFF;">&quot;deno:oak@12&quot;</span><span style="color:#E1E4E8;">,</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#79B8FF;">&quot;chalk&quot;</span><span style="color:#E1E4E8;">: </span><span style="color:#9ECBFF;">&quot;npm:chalk@5&quot;</span></span>
<span class="line"><span style="color:#E1E4E8;">  }</span></span>
<span class="line"><span style="color:#E1E4E8;">}</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#24292E;">{</span></span>
<span class="line"><span style="color:#24292E;">  </span><span style="color:#005CC5;">&quot;imports&quot;</span><span style="color:#24292E;">: {</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#005CC5;">&quot;oak&quot;</span><span style="color:#24292E;">: </span><span style="color:#032F62;">&quot;deno:oak@12&quot;</span><span style="color:#24292E;">,</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#005CC5;">&quot;chalk&quot;</span><span style="color:#24292E;">: </span><span style="color:#032F62;">&quot;npm:chalk@5&quot;</span></span>
<span class="line"><span style="color:#24292E;">  }</span></span>
<span class="line"><span style="color:#24292E;">}</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br></div></div><p>使用方式也很简单，还是和以前一样，oak(类似于 Koa 的服务端框架) 来自于 deno， chalk 来自于 npm</p><div class="language-json vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">json</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#E1E4E8;">import oak from </span><span style="color:#9ECBFF;">&quot;oak&quot;</span><span style="color:#E1E4E8;">;</span></span>
<span class="line"><span style="color:#E1E4E8;">import chalk from </span><span style="color:#9ECBFF;">&quot;chalk&quot;</span><span style="color:#E1E4E8;">;</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#24292E;">import oak from </span><span style="color:#032F62;">&quot;oak&quot;</span><span style="color:#24292E;">;</span></span>
<span class="line"><span style="color:#24292E;">import chalk from </span><span style="color:#032F62;">&quot;chalk&quot;</span><span style="color:#24292E;">;</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><p>总的来说，Deno 在向好的方向发展，自己捡回了以前 node 积累下来的生态去走兼容路线，并且同时在发展自己的特色。</p><p>这里有一个官方给出的和 Node 的特性对比：</p><table><thead><tr><th>Deno</th><th>Node</th></tr></thead><tbody><tr><td>[√] 数以百万计的社区模块</td><td>[√] 数以百万计的社区模块</td></tr><tr><td>[√] 内置 V8 引擎</td><td>[√] 内置 V8 引擎</td></tr><tr><td>[√] 默认安全的运行时(使用文件/网络等能力时需要赋予权限，可以防止三方包的违法行为)</td><td>[×] 不保证运行时安全</td></tr><tr><td>[√] 内置 TypeScript、JSX、一整套代码开发工具链</td><td>[×] 要配置一大堆的工具链文件</td></tr><tr><td>[√] 写原生 Rust 扩展很简单</td><td>[×] 写原生 C++ 扩展老复杂了</td></tr><tr><td>[√] 内置浏览器标准 API</td><td>[×] 不覆盖完整的浏览器 API</td></tr><tr><td>[√] 所有标准库</td><td>[×] 有限的标准库</td></tr></tbody></table><p>同时网络请求的性能也超 Node.js 一倍，当然这些都是实验性数据，实际上生产项目后效果怎样还要打个问号 ？</p><p><img src="https://cdn.jsdelivr.net/gh/PuffMeow/PictureSave/doc/image-20230830002425523.png" alt="image-20230830002425523"></p><p>另外还有一个用 Zig 语言写的 Bun JavaScript 运行时也值得关注一下~</p>`,26),p=[o];function l(r,c,d,i,u,E){return a(),n("div",null,p)}const b=s(e,[["render",l]]);export{m as __pageData,b as default};
