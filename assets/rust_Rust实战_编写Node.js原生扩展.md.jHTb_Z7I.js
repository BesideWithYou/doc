import{_ as s,o as a,c as n,R as i}from"./chunks/framework.KeRvpApV.js";const u=JSON.parse('{"title":"","description":"","frontmatter":{},"headers":[],"relativePath":"rust/Rust实战/编写Node.js原生扩展.md","filePath":"rust/Rust实战/编写Node.js原生扩展.md","lastUpdated":1702828825000}'),p={name:"rust/Rust实战/编写Node.js原生扩展.md"},e=i(`<h2 id="前言" tabindex="-1">前言 <a class="header-anchor" href="#前言" aria-label="Permalink to &quot;前言&quot;">​</a></h2><p>本文将带你了解 Node.js 原生扩展(Native Addon)，并从零去使用 Rust 构建一个 Node.js 原生扩展。</p><p>Node.js 原生扩展可以给 Node.js 提供一个性能逃生通道，当我们使用 Node.js 遇到性能瓶颈或 CPU 密集计算场景的时候，便可以编写 Native Addon 解决这个问题了，比如 swc(对应 babel)、Rspack(对应 Webpack)、Biome(对应 eslint、prettier、babel、webpack 等，目标是代替我们所熟悉的所有前端工具链...)，上面提到的工具链性能比使用纯 Node.js 编写的对应功能的包都有了极大的提高，同时 Native Addon 是支持多线程的，你编写的多线程代码在 Node.js 中一样可以跑（脱离了 V8 引擎单线程执行的限制），正如 <a href="https://swc.rs/" target="_blank" rel="noreferrer">swc</a> 宣传的那样，它在单线程下比 babel 快 20 倍，在 4 核的环境下比 babel 快 70 倍，那么这就解决了 Node.js 不擅长 CPU 密集型的问题。</p><p>在前端架构和工具领域目前 Rust 已经差不多是标配了，Vite 底层使用的 Rollup 的代替品 <a href="https://github.com/rolldown-rs/rolldown_legacy/issues/131" target="_blank" rel="noreferrer">Rolldown</a> 也正在开发中，不过目前还没开放出来，另外还有最近几天火起来的 <a href="https://github.com/oxc-project/oxc/tree/main" target="_blank" rel="noreferrer">Oxlint</a> (一个比 Eslint 快 50-100 倍的 Lint 工具)，连尤大都在夸。</p><p><img src="https://cdn.jsdelivr.net/gh/PuffMeow/PictureSave/doc/image-20231217181133162.png" alt="image-20231217181133162"></p><p>不过要是你说在日常开发中也用不到去接触这么些 Rust 写的底层的工具库啊，那来了解了解总可以吧，以后前端工具全部 Rust 化了，你还能知道怎么去给一些工具去写扩展插件来做更多的事情。</p><p>除了在前端工具之外，其实也有一些库把它用在服务端了，毕竟目前在国外 Node.js 已经是最常用的服务端环境了；另外如果在 SSR 场景中，如果只是想部分使用 Rust 来提速，那么可以使用 Rust 去做解析字符串和模板引擎一些需要吃 CPU 的部分，也能获得一部分的性能收益，但是如果想要获得更高的性能收益，那么整个 SSR 渲染后端都可以替换为 Rust，从公司层面来说可以减少一部分机器成本，让单个机器可以承载更多的 QPS 。</p><p>啥，你说为啥不选用别的语言而用 Rust？一方面是 Rust 其实上手之后开发效率真不低，一些最难最复杂的部分在日常应用层面开发基本都不会接触到，比如写一个链表什么的都有现成封装好的库了，另外很多应用层框架都已经帮你处理掉生命周期的事情了；一方面是 Rust 拥有比别的语言更好的跨语言调用特性；另一方面 Rust 拥有类似于前端的工具链 cargo 以及和 TypeScript 相似的类型系统，如下:</p><div class="language-rust vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">rust</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// Rust 声明变量</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">let</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> a</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">:</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> &amp;</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">str</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &quot;Hello world&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// TypeScript 声明变量</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">let</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> a</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">:</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> string </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &quot;Hello world&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// Rust 泛型函数</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">pub</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> fn</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> walkdir</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&lt;</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">T</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;(entry</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">:</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> String</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, callback</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">:</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> T</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">where</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">  T</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">:</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> Fn</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">String</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">-&gt;</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> Result</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&lt;()&gt;,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">{}</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// TypeScript 泛型函数</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">export function walkdir&lt;</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">T</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> extends (s</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">:</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> string) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> void&gt;(entry</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">:</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> string, callback</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">:</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> T</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {}</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br></div></div><p>C/C++、Java、Go 这些常见语言都是类型前置声明，对比 TS 的后置类型声明，对于前端开发者来说那肯定还是 Rust 更加亲切了。</p><p>最后虽然现在可以使用 AI 来辅助学习了，不过目前 GPT 模型里暂时还没这包括这一部分最新的语料，另外你没了解过这块知识，也不知道怎么去问 AI，所以来了解一下总没错的。</p><h2 id="前置知识" tabindex="-1">前置知识 <a class="header-anchor" href="#前置知识" aria-label="Permalink to &quot;前置知识&quot;">​</a></h2><p>在编写我们的原生扩展之前，我们先了解一下它的相关知识。</p><p>Native Addon 是用 C/C++ 编写的动态链接共享对象。 require() 函数可以将原生扩展加载为普通的 Node.js 模块，它提供了 JavaScript 和 C/C++ 库之间的接口，其实本质上就是我们能够直接在 JS 中调用原生语言编译出来的 xxx.node 二进制文件里导出的方法，这些方法称为 ABI（Application Binary Interface 应用二进制接口）。</p><p>编写 Native Addon 需要依赖 Node.js 提供的 <a href="https://nodejs.org/api/n-api.html" target="_blank" rel="noreferrer">Node-API</a> ，它是 Node.js 提供的编写原生扩展的 API，不和底层 JS 运行时进行绑定，在 Node.js 中独立于 V8 引擎，这样做是为了与 JS 运行时引擎的变化相隔离开，防止因为引擎的一些迭代导致 API 不稳定。</p><p>其实在日常的项目开发中，我们可能都已经已经接触到过不少的 Native Addon 了，举个例子，比如 <a href="https://www.npmjs.com/package/node-sass" target="_blank" rel="noreferrer">node-sass</a>、<a href="https://www.npmjs.com/package/sqlite3?activeTab=code" target="_blank" rel="noreferrer">sqlite3</a> 这两个 C++ 编写的库，在它们的构建产物中，你会看到 C++ 代码和 bingding.gyp 文件，bingding.gyp 用于配置 Native Addon 编译。</p><p><img src="https://cdn.jsdelivr.net/gh/PuffMeow/PictureSave/doc/image-20231217141423921.png" alt="image-20231217141423921"></p><p>当我们进行 <code>npm install node-sass</code> 时，这个包就会下载到用户本地并进行编译，然后构建出符合用户当前平台的 .node 动态链接库，但是很多人用这个包的时候往往会进行各种莫名其妙的报错，这是因为 node-gyp 需要依赖 Python 环境和 C++ 构建工具链，这一步就会把挺多人给劝退掉；另外假如环境顺利安装了，而一旦当这个库变得庞大，在本地构建的时间也会变得非常的长，有一些没耐心的用户可能会觉得电脑卡死了，索性就放弃了，所以这也是其中一个为什么在以前没有大规模去普及 Node.js Native Addon 的原因。</p><p>得益于 Rust 强大的工具链和它本身的语言特性，用它来编写 ABI、FFI(Foreign Function Interface 外部函数接口) 都是非常方便的，现在社区上有了最流行的使用 Rust 来编写 Node.js Native Addon 的框架 <a href="https://napi.rs/" target="_blank" rel="noreferrer">NAPI-RS</a>，使用它来编写原生扩展非常的方便，所以社区上目前新兴的高性能 Node.js 原生扩展都使用 Rust 来进行编写了。而 Node.js 和 Node-API 本身都是使用 C++ 来进行编写的，那么 Rust 想要去调用 C++ 的方法就需要通过 FFI 来进行实现，NAPI-RS 这个框架就是提供了 Rust 版本的 Node-API 的封装，底层通过调用 Node-API，简化了用户对于操作原生 Node-API 的上手成本。 这个框架目前在下面这些工具中都有进行使用：</p><p><img src="https://cdn.jsdelivr.net/gh/PuffMeow/PictureSave/doc/image-20231217152027097.png" alt="image-20231217152027097"></p><p>下面我们就从零讲讲如何去使用 Rust 来编写原生扩展。</p><h2 id="前置条件" tabindex="-1">前置条件 <a class="header-anchor" href="#前置条件" aria-label="Permalink to &quot;前置条件&quot;">​</a></h2><ul><li>Rust 环境：去<a href="https://www.rust-lang.org/" target="_blank" rel="noreferrer">官网</a>自行安装</li><li>Node.js 环境：去<a href="https://nodejs.org/en" target="_blank" rel="noreferrer">官网</a>自行安装</li><li>@napi-rs/cli：全局安装 <code>npm install -g @napi-rs/cli</code></li></ul><h2 id="示例项目" tabindex="-1">示例项目 <a class="header-anchor" href="#示例项目" aria-label="Permalink to &quot;示例项目&quot;">​</a></h2><p>这里我们直接从零用一个例子来讲讲如何开始</p><h3 id="_1-初始化项目" tabindex="-1">1.初始化项目 <a class="header-anchor" href="#_1-初始化项目" aria-label="Permalink to &quot;1.初始化项目&quot;">​</a></h3><p><img src="https://cdn.jsdelivr.net/gh/PuffMeow/PictureSave/doc/image-20230812171630131.png" alt="image-20230812171630131"></p><p>可以看着上面这个图的步骤来：</p><ol><li><code>napi new</code></li><li>输入下包名，推荐去 npm 上创建一个自己的组织，我们这里就用 @puffmeow，然后包名就是 @puffmeow/example</li><li>当前项目的目录名</li><li>选择要支持的平台，Native Addon 是不能跨平台的，所以要选择跨平台构建，这里我们直接按 a 进行全选，全平台构建</li><li>这个我们如果使用 Github workflow 来构建的话，就选上，到时候会通过 github workflow 把所有的包放到容器中进行跨平台构建和发布</li><li>等待项目初始化完成</li></ol><div class="language- vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span>test</span></span>
<span class="line"><span>└── example</span></span>
<span class="line"><span>    ├── Cargo.toml</span></span>
<span class="line"><span>    ├── .github</span></span>
<span class="line"><span>    │   └── CI.yml</span></span>
<span class="line"><span>    ├── __test__</span></span>
<span class="line"><span>    │   └── index.spec.mjs</span></span>
<span class="line"><span>    ├── build.rs</span></span>
<span class="line"><span>    ├── npm</span></span>
<span class="line"><span>    │   ├── android-arm-eabi</span></span>
<span class="line"><span>    │   │   ├── README.md</span></span>
<span class="line"><span>    │   │   └── package.json</span></span>
<span class="line"><span>    │   ├── android-arm64</span></span>
<span class="line"><span>    │   │   ├── README.md</span></span>
<span class="line"><span>    │   │   └── package.json</span></span>
<span class="line"><span>    │   ├── darwin-arm64</span></span>
<span class="line"><span>    │   │   ├── README.md</span></span>
<span class="line"><span>    │   │   └── package.json</span></span>
<span class="line"><span>    │   ├── darwin-universal</span></span>
<span class="line"><span>    │   │   ├── README.md</span></span>
<span class="line"><span>    │   │   └── package.json</span></span>
<span class="line"><span>    │   ├── darwin-x64</span></span>
<span class="line"><span>    │   │   ├── README.md</span></span>
<span class="line"><span>    │   │   └── package.json</span></span>
<span class="line"><span>    │   ├── freebsd-x64</span></span>
<span class="line"><span>    │   │   ├── README.md</span></span>
<span class="line"><span>    │   │   └── package.json</span></span>
<span class="line"><span>    │   ├── linux-arm-gnueabihf</span></span>
<span class="line"><span>    │   │   ├── README.md</span></span>
<span class="line"><span>    │   │   └── package.json</span></span>
<span class="line"><span>    │   ├── linux-arm64-gnu</span></span>
<span class="line"><span>    │   │   ├── README.md</span></span>
<span class="line"><span>    │   │   └── package.json</span></span>
<span class="line"><span>    │   ├── linux-arm64-musl</span></span>
<span class="line"><span>    │   │   ├── README.md</span></span>
<span class="line"><span>    │   │   └── package.json</span></span>
<span class="line"><span>    │   ├── linux-x64-gnu</span></span>
<span class="line"><span>    │   │   ├── README.md</span></span>
<span class="line"><span>    │   │   └── package.json</span></span>
<span class="line"><span>    │   ├── linux-x64-musl</span></span>
<span class="line"><span>    │   │   ├── README.md</span></span>
<span class="line"><span>    │   │   └── package.json</span></span>
<span class="line"><span>    │   ├── win32-arm64-msvc</span></span>
<span class="line"><span>    │   │   ├── README.md</span></span>
<span class="line"><span>    │   │   └── package.json</span></span>
<span class="line"><span>    │   ├── win32-ia32-msvc</span></span>
<span class="line"><span>    │   │   ├── README.md</span></span>
<span class="line"><span>    │   │   └── package.json</span></span>
<span class="line"><span>    │   └── win32-x64-msvc</span></span>
<span class="line"><span>    │       ├── README.md</span></span>
<span class="line"><span>    │       └── package.json</span></span>
<span class="line"><span>    ├── package.json</span></span>
<span class="line"><span>    ├── rustfmt.toml</span></span>
<span class="line"><span>    ├── src</span></span>
<span class="line"><span>    │   └── lib.rs</span></span>
<span class="line"><span>    └── yarn.lock</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br><span class="line-number">26</span><br><span class="line-number">27</span><br><span class="line-number">28</span><br><span class="line-number">29</span><br><span class="line-number">30</span><br><span class="line-number">31</span><br><span class="line-number">32</span><br><span class="line-number">33</span><br><span class="line-number">34</span><br><span class="line-number">35</span><br><span class="line-number">36</span><br><span class="line-number">37</span><br><span class="line-number">38</span><br><span class="line-number">39</span><br><span class="line-number">40</span><br><span class="line-number">41</span><br><span class="line-number">42</span><br><span class="line-number">43</span><br><span class="line-number">44</span><br><span class="line-number">45</span><br><span class="line-number">46</span><br><span class="line-number">47</span><br><span class="line-number">48</span><br><span class="line-number">49</span><br><span class="line-number">50</span><br><span class="line-number">51</span><br><span class="line-number">52</span><br><span class="line-number">53</span><br><span class="line-number">54</span><br><span class="line-number">55</span><br><span class="line-number">56</span><br></div></div><p>对于目录的解释： 其中 npm 目录下的包用来放不同平台构建出来的 .node 文件并通过 workflow 流水线发布到 NPM 上。 用户使用的时候就会根据自己的平台，去自动拉取对应平台的 .node 包，比如我的电脑是 Windows x64 系统，到时候执行 <code>npm install @puffmeow/example</code> 的时候，就会自动去拉取 <code>@puffmeow/example-win32-x64-msvc</code> 这个包，这个包里的 .node 文件里导出的方法就能直接被 JS 进行调用了，和上文提到的使用 node-gyp 在用户本地构建的方式不一样，NAPI-RS 可以通过流水线在云端进行构建并编译，这就避免了之前所说的 node-gyp 存在的问题，并大大节省了用户的本地构建时间。</p><h3 id="_2-编写业务代码" tabindex="-1">2.编写业务代码 <a class="header-anchor" href="#_2-编写业务代码" aria-label="Permalink to &quot;2.编写业务代码&quot;">​</a></h3><p>去到 <code>src/lib.rs</code> 编写你要写的代码即可，默认 NAPI-RS 脚手架会给你初始化一个 sum 方法，使用 [napi] 属性宏的方法可以暴露到 JS 侧。</p><div class="language-rust vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">rust</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">#</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">!</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">[deny(clippy</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">all)]</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">#[macro_use]</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">extern</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> crate</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> napi_derive;</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">#[napi]</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">pub</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> fn</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> sum</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(a</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">:</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> i32</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, b</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">:</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> i32</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">-&gt;</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> i32</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  a </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">+</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> b</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br></div></div><h3 id="_3-ci-脚本" tabindex="-1">3. CI 脚本 <a class="header-anchor" href="#_3-ci-脚本" aria-label="Permalink to &quot;3. CI 脚本&quot;">​</a></h3><p>在.github 目录下，脚手架会给你默认生成一个 CI.yml 脚本，里面包含了在不同平台的容器中进行构建的配置，另外它会默认在你提交代码到主分支并且提交信息为 x.x.x 的时候自动帮你打包构建并发布到 NPM 中，为了能够自动把包发布到 NPM 上，还需要配置一下 NPM Token。</p><h3 id="_4-配置-npm-token-到-github-action" tabindex="-1">4.配置 NPM Token 到 Github Action <a class="header-anchor" href="#_4-配置-npm-token-到-github-action" aria-label="Permalink to &quot;4.配置 NPM Token 到 Github Action&quot;">​</a></h3><p>打开 NPM 的 Access Tokens</p><p><img src="https://cdn.jsdelivr.net/gh/PuffMeow/PictureSave/doc/image-20231215234258269.png" alt="image-20231215234258269"></p><p>然后创建一个 Classic Token，然后类型选择 Automation，最后创建后把得到的 Token 复制到你 Git 项目下的 Setting 对应的配置里，如下图</p><p><img src="https://cdn.jsdelivr.net/gh/PuffMeow/PictureSave/doc/image-20231215234342603.png" alt="image-20231215234342603"></p><p>在对应项目的 setting 里加上 NPM_TOKEN，然后配置这一步就大功告成了</p><p><img src="https://cdn.jsdelivr.net/gh/PuffMeow/PictureSave/doc/image-20231215234528238.png" alt="image-20231215234528238"></p><h3 id="_5-发布" tabindex="-1">5.发布 <a class="header-anchor" href="#_5-发布" aria-label="Permalink to &quot;5.发布&quot;">​</a></h3><p>现在你可以在你初始化的项目里尝试性的发布一下，比如把包的版本号改成 0.0.1，然后提交信息 0.0.1，把改动 push 到主分支上，等待流水线构建完成。到了这里你就能够成功的发布你的第一个使用 Rust 编写的 NPM 包了，现在包里默认会导出一个 sum 方法，构建完成之后，把这个包安装下来，就能直接调用这个包里导出的 sum 方法了。</p><h2 id="其它" tabindex="-1">其它 <a class="header-anchor" href="#其它" aria-label="Permalink to &quot;其它&quot;">​</a></h2><p>之前我自己也写了两个 Rust 编写的 Native Addon，也可以去做下参考，分别是：</p><ul><li><a href="https://github.com/PuffMeow/rusty-schema2ts" target="_blank" rel="noreferrer">@puffmeow/rusty-schema2ts</a>：将 json-schema 转换成 TS 类型的库，性能比纯 JS 版的要快 1 倍。</li><li><a href="https://github.com/PuffMeow/rusty-walkdir" target="_blank" rel="noreferrer">@puffmeow/rusty-walkdir</a>：遍历目录，对 Rust 版的 walkdir 进行了封装，暴露给 node.js 使用</li></ul><p>NAPI 官方也提供了一些包，比如 <a href="https://github.com/napi-rs/node-rs" target="_blank" rel="noreferrer">node-rs</a>， 想要自己编写 Native Addon 的话可以去参考一下，里面提供的包对比 JS 版都有了很大的性能提升。</p><h2 id="总结" tabindex="-1">总结 <a class="header-anchor" href="#总结" aria-label="Permalink to &quot;总结&quot;">​</a></h2><p>使用 Rust 编写 Native Addon 的好处上面也提到了，另一方面就是你可以把一些 Rust 生态的库提供给 Node.js 使用，让别的开发者能够享受到更高性能的前端工具链，这对于整个前端社区来说都是有好处的，毕竟时间就是金钱。之前我也试用了一下字节跳动开源的 Rspack，在一个中大型项目 (5W 行代码左右)，使用 Webpack 冷启动大概在 15s 左右，使用 Rspack 在 1s 内就能启动完成，热更新甚至在 100ms 以内，这还是在没有任何优化配置的情况下，这对于前端社区来说无疑是极大的进步，前端生态的工具也会因此进一步的走向更成熟。最后，Rust 就算不想花时间学习，也是需要去了解一下的，毕竟前端社区未来趋势就是锈化。</p>`,51),l=[e];function r(t,h,c,k,d,o){return a(),n("div",null,l)}const g=s(p,[["render",r]]);export{u as __pageData,g as default};
