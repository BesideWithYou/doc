import{_ as t,o as e,c as a,R as s}from"./chunks/framework.Cb3GRYqX.js";const R=JSON.parse('{"title":"用 Rust 写了个 Node.js 拓展速度提升了 100%？","description":"","frontmatter":{},"headers":[],"relativePath":"rust/心得/用Rust写了个Node扩展.md","filePath":"rust/心得/用Rust写了个Node扩展.md","lastUpdated":1692204806000}'),d={name:"rust/心得/用Rust写了个Node扩展.md"},o=s('<h1 id="用-rust-写了个-node-js-拓展速度提升了-100" tabindex="-1">用 Rust 写了个 Node.js 拓展速度提升了 100%？ <a class="header-anchor" href="#用-rust-写了个-node-js-拓展速度提升了-100" aria-label="Permalink to &quot;用 Rust 写了个 Node.js 拓展速度提升了 100%？&quot;">​</a></h1><h2 id="前言" tabindex="-1">前言 <a class="header-anchor" href="#前言" aria-label="Permalink to &quot;前言&quot;">​</a></h2><blockquote><p>上一篇文章我们介绍了如何使用 Rust 操作 json 文件，刚好最近使用 Rust 写了一个 Node.js Native Addon 小工具来操作 json，对比下来速度提升了 100%，这其实在预料之中，毕竟 Rust 编译型原生语言比 Node.js 性能高是必然的。</p></blockquote><p>先贴一组我使用 Rust 和 TypeScript 写的相同功能的工具的性能对比，这个包的作用是将 JsonSchema 转换为 TypeScript 类型，它们的代码逻辑是完全一样的，最后得到的结果是性能提升了接近 100%(用的笔记本 10 代 i7 跑的)，当然换 C++ 或者 C 语言来写 Native Addon 可能也差不多是这个结果，但是我更熟悉 Rust 一些，所以就用 Rust 来搞了~， 这篇文章主要来讲讲我用 Rust 开发 Node.js 工具时的感受。</p><table><thead><tr><th>index</th><th>Task Name</th><th>ops/sec</th><th>Average Time (ns)</th><th>Margin</th><th>Samples</th></tr></thead><tbody><tr><td>0</td><td>TypeScript: schema2ts</td><td>2,796</td><td>357534.31021794415</td><td>±1.08%</td><td>1399</td></tr><tr><td>1</td><td>Rust: rustySchema2ts</td><td>5,431</td><td>184122.05448994122</td><td>±0.29%</td><td>2716</td></tr></tbody></table><p>感兴趣的同学可以去 NPM 上看下 <code>@puffmeow/rusty-schema2ts</code> 这个包。</p><h2 id="开发时的感受" tabindex="-1">开发时的感受 <a class="header-anchor" href="#开发时的感受" aria-label="Permalink to &quot;开发时的感受&quot;">​</a></h2><h3 id="用-windows-系统开发蛋疼" tabindex="-1">用 Windows 系统开发蛋疼 <a class="header-anchor" href="#用-windows-系统开发蛋疼" aria-label="Permalink to &quot;用 Windows 系统开发蛋疼&quot;">​</a></h3><p>不得不说，用 Windows 系统开发心态就是很搞，很多 Unix 的命令都不支持（虽然可以在虚拟机里跑，但体验也不爽），有条件的还是整一个 Mac 来开发会舒服很多。还有 Windows 的换行符默认用的 CRLF 就很蛋疼，在 Unix 系统上都是 LF，这会导致跑单测的时候会出现报错，明明单测对比结果完全一致但就是不通过，就是因为这个换行符导致的。</p><h3 id="写代码时感觉还行" tabindex="-1">写代码时感觉还行 <a class="header-anchor" href="#写代码时感觉还行" aria-label="Permalink to &quot;写代码时感觉还行&quot;">​</a></h3><p>写这个工具的时候核心逻辑全部用的 Rust，然后单元测试用的 Vitest，整体开发下来感受还行，只要熟悉 Rust ，开发时基本没遇到啥太大的问题，也没遇见 Rust 所有权、生命周期这些难啃的骨头，也可能是我这个场景太简单了哈哈~，不过如果遇到所有权问题的时候，套一下 Rc 或者 Arc 也能很快解决，问题不大。</p><h3 id="跨平台很麻烦" tabindex="-1">跨平台很麻烦 <a class="header-anchor" href="#跨平台很麻烦" aria-label="Permalink to &quot;跨平台很麻烦&quot;">​</a></h3><p>首先是跨平台这个问题，Native Addon 是不支持跨平台的，在每个平台上只能编译出自己对应平台的 node 文件，如果你想要这个包能够分发给全平台的机器用，就需要在这些不同平台的容器/虚拟机中进行构建， napi-rs 提供了很便捷的跨平台构建工具，有了这个工具后我们还需要依赖 Github workflow，通过流水线在不同平台的容器构建好，最后在云端进行发布 NPM 包。这整个构建的流程如下图，我这个工具核心代码 800 行左右，每次发布都需要差不多 10 分钟，这其中包括了构建和跑测试用例的过程。想要改点东西时重新发包就要等很久~ 而且要构建的时候十分依赖于 Github，很多公司里面都没集成这样的跨平台构建流水线（阿里集团内部目前也没看到有，倒是蚂蚁是有的）</p><p><img src="https://cdn.jsdelivr.net/gh/PuffMeow/PictureSave/doc/image-20230817002333644.png" alt="image-20230817002333644"></p><h2 id="总结" tabindex="-1">总结 <a class="header-anchor" href="#总结" aria-label="Permalink to &quot;总结&quot;">​</a></h2><p>掌握了使用 Rust 编写 Node.js 工具后，以后一些吃 CPU 计算的工具都可以用 Rust 来写给 Node.js 调用了~ 特别是读写文件，Swc/Rspack/Farm/Rome 这些工具都是读写文件类型的，所以它们宣传性能提高了 xx 倍也很合理。首先是因为 Rust 性能本身就好，其次是因为架构设计得合理，最后才有了性能提高 xx 倍的结果。如果使用 Node.js 写服务端，那其实就不需要考虑上面的跨平台构建了，把 Rust 代码在本地写好之后，最后到服务器上构建的时候只需要构建当前服务器这个平台即可。但是可能有人会问，为什么不直接就用 Rust 来写服务端了呢，还要搞这么麻烦？ 原因是 Node.js 开发效率比较高，而且只有在遇见吃性能场景的时候我们才会去使用 Rust，大部分场景其实都是 IO 密集型场景，也没太大必要，当然你也可以单独起一个 Rust 微服务，但是这时候就会多一层网络开销，网络传输大概是没有本地调用的速度快的。就这么个回事。</p><p>最后，Rust 这玩意感兴趣就学，不感兴趣看看就好，大部分开发的场景中我们是遇不见 CPU 密集型场景的，但是一旦遇到的时候，我们就要能够有对应的解决手段，这就是我们的能力。</p>',17),r=[o];function i(h,n,u,c,l,p){return e(),a("div",null,r)}const m=t(d,[["render",i]]);export{R as __pageData,m as default};
