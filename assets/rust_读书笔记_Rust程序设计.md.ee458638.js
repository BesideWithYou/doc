import{_ as s,o as a,c as e,Q as o}from"./chunks/framework.18ed7b43.js";const h=JSON.parse('{"title":"","description":"","frontmatter":{},"headers":[],"relativePath":"rust/读书笔记/Rust程序设计.md","filePath":"rust/读书笔记/Rust程序设计.md","lastUpdated":1698680036000}'),n={name:"rust/读书笔记/Rust程序设计.md"},p=o(`<h2 id="读书记录" tabindex="-1">读书记录 <a class="header-anchor" href="#读书记录" aria-label="Permalink to &quot;读书记录&quot;">​</a></h2><h3 id="所有权和移动" tabindex="-1">所有权和移动 <a class="header-anchor" href="#所有权和移动" aria-label="Permalink to &quot;所有权和移动&quot;">​</a></h3><p>需要了解 Copy 和 Clone 的区别，以及了解所有权的移动。</p><p>所有权的移动 1 比.0 如</p><div class="language-rust vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">rust</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#F97583;">let</span><span style="color:#E1E4E8;"> a </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> </span><span style="color:#9ECBFF;">&quot;a&quot;</span><span style="color:#F97583;">.</span><span style="color:#B392F0;">to_string</span><span style="color:#E1E4E8;">();</span></span>
<span class="line"><span style="color:#F97583;">let</span><span style="color:#E1E4E8;"> b </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> a;</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#D73A49;">let</span><span style="color:#24292E;"> a </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> </span><span style="color:#032F62;">&quot;a&quot;</span><span style="color:#D73A49;">.</span><span style="color:#6F42C1;">to_string</span><span style="color:#24292E;">();</span></span>
<span class="line"><span style="color:#D73A49;">let</span><span style="color:#24292E;"> b </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> a;</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><p>a 的值的所有权会移动到 b，a 会变成未初始化的状态。</p><p>标准的 Copy 类型包括所有机器整数类型、浮点数类型、char、bool 类型，以及 Copy 类型的元组或固定大小的数组。 String、Box 不是 Copy 类型，因为它们拥有堆中的内存，File 类型不是 Copy 类型，因为它需要向操作系统申请文件句柄，MutexGuard 表示一个互斥锁，它最终需要释放锁，所以任何在丢弃值需要做一些特殊操作的类型都不是 Copy 类型。</p><p>对于 Struct 结构体，如果里面的所有类型都是 Copy 类型，那么可以通过 #[derive(Copy,Clone)] 属性放在结构体上面，就可以让这个结构体变为 Copy 类型，但如果结构体里面只要有一个不是 Copy 类型，那么这样做就会编译报错。</p><p>如果想要像 Python 一样赋值时增加引用计数，而不是发生移动，可以使用 Rc(非线程安全)/Arc(线程安全)，它是引用计数智能指针，它本身拥有的值不可变。</p><p>记住一句话：在 Rust 中的值，共享不可变，可变不共享。</p><h3 id="引用" tabindex="-1">引用 <a class="header-anchor" href="#引用" aria-label="Permalink to &quot;引用&quot;">​</a></h3>`,11),t=[p];function l(r,c,i,d,u,y){return a(),e("div",null,t)}const E=s(n,[["render",l]]);export{h as __pageData,E as default};
