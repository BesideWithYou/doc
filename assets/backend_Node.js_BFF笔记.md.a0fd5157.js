import{_ as e,c as l,o as i,d as a}from"./app.d8d6edb2.js";const r="/doc/assets/1.5a1ff202.png",d="/doc/assets/2.d18c4359.png",t="/doc/assets/3.a1117a6a.png",B=JSON.parse('{"title":"","description":"","frontmatter":{},"headers":[{"level":2,"title":"大纲","slug":"大纲","link":"#大纲","children":[{"level":3,"title":"微服务","slug":"微服务","link":"#微服务","children":[]},{"level":3,"title":"BFF","slug":"bff","link":"#bff","children":[]},{"level":3,"title":"网关","slug":"网关","link":"#网关","children":[]},{"level":3,"title":"集群化","slug":"集群化","link":"#集群化","children":[]},{"level":3,"title":"RPC","slug":"rpc","link":"#rpc","children":[]},{"level":3,"title":"sofa-rpc-node 框架","slug":"sofa-rpc-node-框架","link":"#sofa-rpc-node-框架","children":[]},{"level":3,"title":"Protocol Buffers","slug":"protocol-buffers","link":"#protocol-buffers","children":[]},{"level":3,"title":"Zookeeper","slug":"zookeeper","link":"#zookeeper","children":[]},{"level":3,"title":"缓存","slug":"缓存","link":"#缓存","children":[]},{"level":3,"title":"消息队列","slug":"消息队列","link":"#消息队列","children":[]},{"level":3,"title":"RabbitMQ","slug":"rabbitmq","link":"#rabbitmq","children":[]}]},{"level":2,"title":"实战案例","slug":"实战案例","link":"#实战案例","children":[]},{"level":2,"title":"BFF的问题","slug":"bff的问题","link":"#bff的问题","children":[]}],"relativePath":"backend/Node.js/BFF笔记.md","lastUpdated":1673191612000}'),o={name:"backend/Node.js/BFF笔记.md"},n=a('<h2 id="大纲" tabindex="-1">大纲 <a class="header-anchor" href="#大纲" aria-hidden="true">#</a></h2><ul><li>BFF 架构演进</li><li>RPC 高性能 BFF 实战</li><li>DDD、GraphQL 实战 BFF</li><li>Serverless 实战 BFF</li></ul><h3 id="微服务" tabindex="-1">微服务 <a class="header-anchor" href="#微服务" aria-hidden="true">#</a></h3><p>优点：将单体应用划分为更小的服务，每个服务可以独立运行并且可以使用不同的语言开发，这些服务可能放在不同的机器上，他们之间的通信协议使用 RPC，该协议比 HTTP 具有更低的延迟和更高的性能</p><p>缺点：</p><ul><li>域名开销增加</li><li>内部服务器暴露在公网，有安全隐患</li><li>各个端有大量的个性化需求 <ul><li>数据聚合 某些功能可能需要调用多个微服务进行组合</li><li>数据裁剪 后端服务返回的数据可能需要过滤掉一些敏感数据</li><li>数据适配 后端返回的数据可能需要针对不同端进行数据结构的适配，后端返回 XML ，但 前端需要 JSON</li><li>数据鉴权 不同的客户端有不同的权限要求</li></ul></li></ul><h3 id="bff" tabindex="-1">BFF <a class="header-anchor" href="#bff" aria-hidden="true">#</a></h3><p>BFF 是 Backend for Frontend 的缩写，指的是专门为前端应用设计的后端服务 主要用来为各个端提供代理数据聚合、裁剪、适配和鉴权服务，方便各个端接入后端服务 BFF 可以把前端和微服务进行解耦，各自可以独立演进</p><img src="'+r+'"><h3 id="网关" tabindex="-1">网关 <a class="header-anchor" href="#网关" aria-hidden="true">#</a></h3><ul><li>API 网关是一种用于在应用程序和 API 之间提供安全访问的中间层</li><li>API 网关还可以用于监控 API 调用，路由请求，以及在请求和响应之间添加附加功能（例如身份验 证，缓存，数据转换，压缩、流量控制、限流熔断、防爬虫等）</li><li>网关和 BFF 可能合二为一</li></ul><img src="'+d+'"><h3 id="集群化" tabindex="-1">集群化 <a class="header-anchor" href="#集群化" aria-hidden="true">#</a></h3><p>单点服务器可能会存在以下几个问题：</p><ul><li>单点故障：单点服务器只有一台，如果这台服务器出现故障，整个系统都会停止工作，这会导 致服务中断</li><li>计算能力有限：单点服务器的计算能力是有限的，无法应对大规模的计算需求</li><li>可扩展性差：单点服务器的扩展能力有限，如果想要提升计算能力，就必须改造或者替换现有 的服务器 这些问题可以通过采用服务器集群的方式来解决 <img src="'+t+'"></li></ul><h3 id="rpc" tabindex="-1">RPC <a class="header-anchor" href="#rpc" aria-hidden="true">#</a></h3><p><code>RPC（Remote Procedure Call）</code> 是远程过程调用的缩写，是一种通信协议，允许程序在不同的 计算机上相互调用远程过程，就像调用本地过程一样</p><h3 id="sofa-rpc-node-框架" tabindex="-1">sofa-rpc-node 框架 <a class="header-anchor" href="#sofa-rpc-node-框架" aria-hidden="true">#</a></h3><p><code>sofa-rpc-node</code> 是(阿里开源)基于 Node.js 的一个 RPC 框架，支持多种协议</p><h3 id="protocol-buffers" tabindex="-1">Protocol Buffers <a class="header-anchor" href="#protocol-buffers" aria-hidden="true">#</a></h3><p><code>Protocol Buffers （简称 protobuf）</code>是 Google 开发的一种数据序列化格式，可以将结构化数 据序列化成二进制格式，并能够跨语言使用</p><h3 id="zookeeper" tabindex="-1">Zookeeper <a class="header-anchor" href="#zookeeper" aria-hidden="true">#</a></h3><p>ZooKeeper 是一个分布式协调服务，提供了一些简单的分布式服务，如配置维护、名字服务、组服务等。它可以用于管理分布式系统中的数据</p><h3 id="缓存" tabindex="-1">缓存 <a class="header-anchor" href="#缓存" aria-hidden="true">#</a></h3><p>一般会使用多级缓存，本地做一层 LRU 缓存，再做一层远程服务器的 Redis 缓存。这些缓存层的优先级通常是依次递减的，即最快的缓存层位于最顶层，最慢的缓存层位于最底层。越上层的缓存缓存时间一般越短</p><h3 id="消息队列" tabindex="-1">消息队列 <a class="header-anchor" href="#消息队列" aria-hidden="true">#</a></h3><p>在 BFF 中使用消息队列（message queue）有几个原因：</p><ul><li>大并发：消息队列可以帮助应对大并发的请求，BFF 可以将请求写入消息队列，然后后端服务 可以从消息队列中读取请求并处理</li><li>解耦：消息队列可以帮助解耦 BFF 和后端服务，BFF 不需要关心后端服务的具体实现，只需 要将请求写入消息队列，后端服务负责从消息队列中读取请求并处理</li><li>异步：消息队列可以帮助实现异步调用，BFF 可以将请求写入消息队列，然后立即返回响应给 前端应用，后端服务在后台处理请求</li><li>流量削峰：消息队列可以帮助流量削峰，BFF 可以将请求写入消息队列，然后后端服务可以在 合适的时候处理请求，从而缓解瞬时高峰流量带来的压力</li></ul><h3 id="rabbitmq" tabindex="-1">RabbitMQ <a class="header-anchor" href="#rabbitmq" aria-hidden="true">#</a></h3><p>RabbitMQ 是一个消息代理，它可以用来在消息生产者和消息消费者之间传递消息 RabbitMQ的工作流程如下：</p><ul><li>消息生产者将消息发送到 RabbitMQ 服务器</li><li>RabbitMQ 服务器将消息保存到队列中</li><li>消息消费者从队列中读取消息</li><li>当消息消费者处理完消息后 RabbitMQ 服务器将消息删除</li></ul><h2 id="实战案例" tabindex="-1">实战案例 <a class="header-anchor" href="#实战案例" aria-hidden="true">#</a></h2><p>todo</p><h2 id="bff的问题" tabindex="-1">BFF的问题 <a class="header-anchor" href="#bff的问题" aria-hidden="true">#</a></h2><ul><li>复杂性增加：添加 BFF 层会增加系统的复杂性，因为它需要在后端 API 和前端应用程序之间处理请 求和响应</li><li>性能问题：如果 BFF 层的实现不当，可能会导致性能问题，因为它需要在后端 API 和前端应用程序 之间传输大量数据</li><li>安全风险：如果 BFF 层未得到正确保护，可能会导致安全风险，因为它可能会暴露敏感数据 维护成本：BFF 层需要维护和更新，这会增加维护成本</li><li>测试复杂性：由于 BFF 层需要在后端 API 和前端应用程序之间进行测试，因此测试可能会变得更加 复杂 运维问题 要求有强大的日志、服务器监控、性能监控、负载均衡、备份冗灾、监控报警和弹性伸缩 扩容等</li></ul><p>但是上述的问题可以使用 Serverless 来进行解决，特别是针对前端来说</p>',36),s=[n];function h(c,p,f,u,b,F){return i(),l("div",null,s)}const k=e(o,[["render",h]]);export{B as __pageData,k as default};
