import{_ as s,c as a,o as n,d as e}from"./app.5233d39c.js";const A=JSON.parse('{"title":"数据库进阶","description":"","frontmatter":{"title":"数据库进阶"},"headers":[{"level":2,"title":"存储引擎","slug":"存储引擎","link":"#存储引擎","children":[{"level":3,"title":"MySQL 体系结构","slug":"mysql-体系结构","link":"#mysql-体系结构","children":[]},{"level":3,"title":"存储引擎简介","slug":"存储引擎简介","link":"#存储引擎简介","children":[]},{"level":3,"title":"存储引擎特点","slug":"存储引擎特点","link":"#存储引擎特点","children":[]}]},{"level":2,"title":"索引（重点）","slug":"索引-重点","link":"#索引-重点","children":[{"level":3,"title":"概念","slug":"概念","link":"#概念","children":[]},{"level":3,"title":"优缺点","slug":"优缺点","link":"#优缺点","children":[]},{"level":3,"title":"索引结构","slug":"索引结构","link":"#索引结构","children":[]},{"level":3,"title":"B-Tree","slug":"b-tree","link":"#b-tree","children":[]},{"level":3,"title":"B+ Tree","slug":"b-tree-1","link":"#b-tree-1","children":[]},{"level":3,"title":"Hash","slug":"hash","link":"#hash","children":[]},{"level":3,"title":"思考","slug":"思考","link":"#思考","children":[]},{"level":3,"title":"索引分类","slug":"索引分类","link":"#索引分类","children":[]},{"level":3,"title":"思考题","slug":"思考题","link":"#思考题","children":[]},{"level":3,"title":"索引语法","slug":"索引语法","link":"#索引语法","children":[]},{"level":3,"title":"SQL 性能分析工具","slug":"sql-性能分析工具","link":"#sql-性能分析工具","children":[]},{"level":3,"title":"索引使用","slug":"索引使用","link":"#索引使用","children":[]},{"level":3,"title":"索引设计原则","slug":"索引设计原则","link":"#索引设计原则","children":[]}]}],"relativePath":"backend/MySQL数据库/2.进阶.md","lastUpdated":1673171268000}'),l={name:"backend/MySQL数据库/2.进阶.md"},p=e(`<h2 id="存储引擎" tabindex="-1">存储引擎 <a class="header-anchor" href="#存储引擎" aria-hidden="true">#</a></h2><h3 id="mysql-体系结构" tabindex="-1">MySQL 体系结构 <a class="header-anchor" href="#mysql-体系结构" aria-hidden="true">#</a></h3><p>连接层：客户端和连接服务，主要做连接处理、验证授权及相关的安全方案。</p><p>↓</p><p>服务层：做核心功能服务，如 SQL 接口，并完成缓存的查询，SQL 的分析和优化，部分内置函数的执行。</p><p>↓</p><p>引擎层（可插拔） 索引在该层实现， InnoDB 是 5.5 版本之后默认的存储引擎。负责 MySQL 中数据的存储和提取，服务器通过 API 和存储引擎进行通信。</p><p>↓</p><p>存储层：主要是将数据存储在文件系统之上，并完成和存储引擎的交互。</p><h3 id="存储引擎简介" tabindex="-1">存储引擎简介 <a class="header-anchor" href="#存储引擎简介" aria-hidden="true">#</a></h3><p>存储引擎就是存储数据、建立索引、更新/查询数据等技术的实现方式。存储引擎是基于表的，而不是基于库的，存储引擎也被称为表类型。</p><p>创建表时，可以指定存储引擎</p><div class="language-sql line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">sql</span><pre class="shiki material-palenight"><code><span class="line"><span style="color:#F78C6C;">CREATE</span><span style="color:#A6ACCD;"> </span><span style="color:#F78C6C;">TABLE</span><span style="color:#A6ACCD;"> </span><span style="color:#82AAFF;">表名</span><span style="color:#A6ACCD;">(</span></span>
<span class="line"><span style="color:#A6ACCD;">  ...</span></span>
<span class="line"><span style="color:#A6ACCD;">) ENGINE </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> INNODB [COMMENT 表注释];</span></span>
<span class="line"></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><h3 id="存储引擎特点" tabindex="-1">存储引擎特点 <a class="header-anchor" href="#存储引擎特点" aria-hidden="true">#</a></h3><h4 id="innodb" tabindex="-1">InnoDB <a class="header-anchor" href="#innodb" aria-hidden="true">#</a></h4><p>它是一种兼顾高可靠性和高性能的通用存储引擎</p><p>特点：DML 操作遵循 ACID 模型，支持事务；</p><p>行级锁，提高并发访问性能；</p><p>支持外键保证数据的完整性和正确性；</p><p>逻辑存储结构：表空间、段、区、页、行</p><h4 id="myisam" tabindex="-1">MyISAM <a class="header-anchor" href="#myisam" aria-hidden="true">#</a></h4><p>MySQL 早期默认存储引擎</p><p>特点：不支持事务、不支持外键；</p><p>支持表锁、不支持行锁；</p><p>访问速度快</p><h4 id="memory" tabindex="-1">Memory <a class="header-anchor" href="#memory" aria-hidden="true">#</a></h4><p>数据存在内存中，断电后数据不在了，只能作为临时表或缓存使用</p><p>特点：内存存放，默认使用 hash 索引</p><h4 id="主要区别" tabindex="-1">主要区别 <a class="header-anchor" href="#主要区别" aria-hidden="true">#</a></h4><p>事务、锁机制、外键</p><table><thead><tr><th>特点</th><th>InnoDB</th><th>MyISAM</th><th>Memory</th></tr></thead><tbody><tr><td>存储限制</td><td>64TB</td><td>有</td><td>有</td></tr><tr><td>事务安全</td><td><strong>支持</strong></td><td>-</td><td>-</td></tr><tr><td>锁机制</td><td><strong>行锁</strong></td><td>表锁</td><td>表锁</td></tr><tr><td>B+Tree 索引</td><td>支持</td><td>支持</td><td>支持</td></tr><tr><td>Hash 索引</td><td>-</td><td>-</td><td>支持</td></tr><tr><td>全文索引</td><td>5.6 版本后支持</td><td>支持</td><td>-</td></tr><tr><td>空间使用</td><td>高</td><td>低</td><td>N/A</td></tr><tr><td>内存使用</td><td>高</td><td>低</td><td>中等</td></tr><tr><td>批量插入速度</td><td>低</td><td>高</td><td>高</td></tr><tr><td>支持外键</td><td><strong>支持</strong></td><td>-</td><td>-</td></tr></tbody></table><h4 id="如何选择" tabindex="-1">如何选择 <a class="header-anchor" href="#如何选择" aria-hidden="true">#</a></h4><p>InnoDB：如果对事务的完整性有比较高的要求，在并发条件下要求数据的一致性，数据操作除了插入和查询之外，还包含很多更新、删除操作，适合选择它</p><p>MyISAM：如果以读操作和插入操作为主，有少量的更新和删除操作，对事务完整性、并发性要求不高，适合选择它。但是真正业务中一般用 MongoDB 来替代了，一般评论可以用 MongoDB。</p><p>MEMORY：数据放在内存中，访问速度快，但是缺陷是对表的大小有限制，太大的表放不进内存，而且不能保证数据安全性。一般业务中都会用 Redis 来替代，一般购物车可以用 Redis。</p><h2 id="索引-重点" tabindex="-1">索引（重点） <a class="header-anchor" href="#索引-重点" aria-hidden="true">#</a></h2><h3 id="概念" tabindex="-1">概念 <a class="header-anchor" href="#概念" aria-hidden="true">#</a></h3><p>帮助 MySQL 高效获取数据的数据结构（有序）。在数据之外，数据库系统还维护者满足特定查找算法的数据结构，这些数据结构以某种方式指向数据，这样就可以在这些数据结构之上实现高级查找算法，这种数据结构就是索引。</p><p>说白了，索引就是一个数据结构，用来提高查找速度。</p><h3 id="优缺点" tabindex="-1">优缺点 <a class="header-anchor" href="#优缺点" aria-hidden="true">#</a></h3><table><thead><tr><th>优点</th><th>缺点</th></tr></thead><tbody><tr><td>提高数据检索效率，降低数据库 IO 成本</td><td>索引列也是占用空间的（存在磁盘，磁盘很便宜，该缺点一般可以忽略）</td></tr><tr><td>通过索引列对数据进行排序，降低数据排 序的成本，降低 CPU 消耗</td><td>索引大大提高了查询效率，同时也降低了更新表的速度，如对表进行插入、更新、删除时，效率会降低</td></tr></tbody></table><h3 id="索引结构" tabindex="-1">索引结构 <a class="header-anchor" href="#索引结构" aria-hidden="true">#</a></h3><p>索引在第三层引擎层实现，在不同的存储引擎会有不同的结构，主要包含：</p><table><thead><tr><th>索引结构</th><th>描述</th></tr></thead><tbody><tr><td>B+Tree 索引</td><td>最常见的索引，大部分引擎都支持</td></tr><tr><td>Hash 索引</td><td>底层数据结构就是哈希表实现的，只有精确匹配索引列的查询才有效，不支持范围查询</td></tr><tr><td>R-tree(空间索引)</td><td>空间索引是 MySAM 引擎的一种特殊索引类型，主要用于地理空间数据类型，使用较少</td></tr><tr><td>Full-text(全文索引)</td><td>通过建立倒排索引，快速匹配文档的方式</td></tr></tbody></table><p>通常说的索引，没特别说明都指的是 B+ Tree</p><h3 id="b-tree" tabindex="-1">B-Tree <a class="header-anchor" href="#b-tree" aria-hidden="true">#</a></h3><p>二叉树具有缺点：顺序插入时，会形成一个链表，查询性能大大降低。大数据量情况下，层级较深，检索速度慢</p><div class="language-text line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">text</span><pre class="shiki material-palenight"><code><span class="line"><span style="color:#A6ACCD;">全往左子树插入形成链表结构：</span></span>
<span class="line"><span style="color:#A6ACCD;"></span></span>
<span class="line"><span style="color:#A6ACCD;">            36</span></span>
<span class="line"><span style="color:#A6ACCD;">          34</span></span>
<span class="line"><span style="color:#A6ACCD;">        33</span></span>
<span class="line"><span style="color:#A6ACCD;">      32</span></span>
<span class="line"><span style="color:#A6ACCD;">    23</span></span>
<span class="line"><span style="color:#A6ACCD;">  22</span></span>
<span class="line"><span style="color:#A6ACCD;">17</span></span>
<span class="line"><span style="color:#A6ACCD;"></span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br></div></div><p>红黑树：大数据量的情况下，层级较深，检索速度慢。（红黑树是 C++的 Set 和 Map 容器的底层实现）</p><p>B 树（多路平衡查找树）</p><p>以一棵最大度数为 5 (5 阶) 的 b-tree 为例（每个节点最多存储 4 个 key，5 个指针）。</p><blockquote><p>树的度数指的是一个节点的子节点个数</p></blockquote><p>演变过程可以去看这个网站：<a href="https://www.cs.usfca.edu/~galles/visualization/Algorithms.html" target="_blank" rel="noreferrer">https://www.cs.usfca.edu/~galles/visualization/Algorithms.html</a></p><h3 id="b-tree-1" tabindex="-1">B+ Tree <a class="header-anchor" href="#b-tree-1" aria-hidden="true">#</a></h3><p>以一棵最大度数为 4 的 B+ Tree 为例：</p><p>和 B-Tree 的区别：</p><p>所有的数据都会出现在叶子节点</p><p>叶子节点会形成一个单向链表</p><p>MySQL 索引数据结构对经典的 B+ Tree 进行了优化，增加了一个指向相邻叶子节点的链表指针，形成了带有顺序指针的 B+ Tree，提高区间访问性能，其实就是变成了循环双向链表。</p><h3 id="hash" tabindex="-1">Hash <a class="header-anchor" href="#hash" aria-hidden="true">#</a></h3><p>哈希索引就是采用一定的哈希算法，将键值换算成新的 hash 值，映射到对应的槽位上，然后存储在 hash 表中。</p><p>如果两个或多个键值，映射到了同一个相同的槽位，就产生了 hash 冲突，可以通过链表来解决。</p><p>特点：</p><p>只能用于对等比较（=， in )，不支持范围查询 (between, &lt; , &gt;)</p><p>无法利用索引完成排序</p><p>查询效率高，通常只需要一次检索就可以了（没有冲突的情况下），效率通常高于 B+ Tree 索引。</p><h3 id="思考" tabindex="-1">思考 <a class="header-anchor" href="#思考" aria-hidden="true">#</a></h3><p>为什么 InnoDB 选择 B+ Tree 索引</p><p>相对于二叉树，层级更少，搜索效率更高；</p><p>对与 B-Tree，无论叶子还是非叶子节点都会保存数据，当一页中存储的键值减少，指针也跟着减少，要同样保存大量数据时， B-Tree 只能增加树的高度，导致性能降低；</p><p>相对 Hash 索引，B+ Tree 支持范围匹配和排序操作；</p><h3 id="索引分类" tabindex="-1">索引分类 <a class="header-anchor" href="#索引分类" aria-hidden="true">#</a></h3><table><thead><tr><th>分类</th><th>含义</th><th>特点</th><th>关键字</th></tr></thead><tbody><tr><td>主键索引</td><td>表中主键创建的索引</td><td>默认自动创建，只能有一个</td><td>PRIMARY</td></tr><tr><td>唯一索引</td><td>避免同一个表中某数据列的值重复</td><td>可以有多个</td><td>UNIQUE</td></tr><tr><td>常规索引</td><td>快速定位特定数据</td><td>可以有多个</td><td></td></tr><tr><td>全文索引</td><td>全文索引查找的是文本中的关键字，而不是比较索引中的值</td><td>可以有多个</td><td>FULLTEXT</td></tr></tbody></table><p>在 InnoDB 引擎中，又可以分为下面两种</p><table><thead><tr><th>分类</th><th>含义</th><th>特点</th></tr></thead><tbody><tr><td>聚集索引</td><td>将数据存储和索引放到一块，索引结构的叶子节点保存了行数据</td><td>必须有，且只能有一个</td></tr><tr><td>二级索引</td><td>将数据和索引分开存储，索引结构的叶子节点关联的是对应的主键</td><td>可以存在多个</td></tr></tbody></table><p>聚集索引和二级索引都是 B+ Tree，只不过聚集索引叶子节点下面挂的是一行的数据，而二级索引叶子节点挂的是主键</p><p>聚集索引选取规则：</p><ul><li>如果存在主键，主键索引就是聚集索引</li><li>如果不存在主键，将使用第一个唯一（UNIQUE）索引作为聚集索引</li><li>如果表没有主键，或没有合适的唯一索引，则 InnoDB 会自动生成一个 rowid 作为隐藏的聚集索引</li></ul><p>回表查询：先去从二级索引拿到对应的主键，再通过聚集索引去拿到对应的行数据</p><h3 id="思考题" tabindex="-1">思考题 <a class="header-anchor" href="#思考题" aria-hidden="true">#</a></h3><h4 id="_1-以下两条-sql-哪条效率更高" tabindex="-1">1.以下两条 SQL 哪条效率更高？ <a class="header-anchor" href="#_1-以下两条-sql-哪条效率更高" aria-hidden="true">#</a></h4><p>备注：id 为主键，name 字段创建的有索引</p><div class="language-sql line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">sql</span><pre class="shiki material-palenight"><code><span class="line"><span style="color:#F78C6C;">select</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">*</span><span style="color:#A6ACCD;"> </span><span style="color:#F78C6C;">from</span><span style="color:#A6ACCD;"> user </span><span style="color:#F78C6C;">where</span><span style="color:#A6ACCD;"> id </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> </span><span style="color:#F78C6C;">10</span><span style="color:#A6ACCD;">;</span></span>
<span class="line"></span>
<span class="line"><span style="color:#F78C6C;">select</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">*</span><span style="color:#A6ACCD;"> </span><span style="color:#F78C6C;">from</span><span style="color:#A6ACCD;"> user </span><span style="color:#F78C6C;">where</span><span style="color:#A6ACCD;"> </span><span style="color:#F78C6C;">name</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">&#39;</span><span style="color:#C3E88D;">Arm</span><span style="color:#89DDFF;">&#39;</span><span style="color:#A6ACCD;">;</span></span>
<span class="line"></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><p>分析：</p><p>第一条只需要走聚集索引，一次扫描即可。</p><p>如果根据 name 字段去查找，则需要先走二级索引找到对应的主键，然后再回表查询才能找到对应行数据，需要走两次查询</p><h4 id="_2-innodb-主键索引的-b-tree-高度有多高" tabindex="-1">2. InnoDB 主键索引的 B+Tree 高度有多高？ <a class="header-anchor" href="#_2-innodb-主键索引的-b-tree-高度有多高" aria-hidden="true">#</a></h4><p>主键索引是聚集索引，每一个节点都称为一页，而且每页的大小都是固定为 16 k 。 InnoDB 的指针占用 6 个字节的空间，如果主键类型为 bigint， 则占用 8 个字节。</p><p>假设：</p><p>数据库的一行数据大小为 1k，一页中可以存储 16 行这样的数据， InnoDB 的指针占用 6 个字节的空间，如果主键类型为 bigint， 占用 8 个字节。</p><p>如果树的高度为 2，可以存储多大的数据？</p><p>指针永远比键多一个，n 指的是主键个数</p><p>n _ 8 + (n+1) _ 6 = 16 * 1024</p><p>n 约等于 1170</p><p>则一共有 1171 个指针，每一个指针指向下面的子节点，一个子节点可以存储 16 行数据</p><p>1171 * 16 = 18736</p><h3 id="索引语法" tabindex="-1">索引语法 <a class="header-anchor" href="#索引语法" aria-hidden="true">#</a></h3><h4 id="创建索引" tabindex="-1">创建索引 <a class="header-anchor" href="#创建索引" aria-hidden="true">#</a></h4><p>一个索引可以关联多个字段，如果一个索引只关联一个字段则称为单列索引，否则称为联合索引</p><div class="language-sql line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">sql</span><pre class="shiki material-palenight"><code><span class="line"><span style="color:#F78C6C;">CREATE</span><span style="color:#A6ACCD;"> [UNIQUE | FULLTEXT] </span><span style="color:#F78C6C;">INDEX</span><span style="color:#A6ACCD;"> 索引名 </span><span style="color:#F78C6C;">ON</span><span style="color:#A6ACCD;"> 表名 (字段名称, ...);</span></span>
<span class="line"></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br></div></div><h4 id="查看索引" tabindex="-1">查看索引 <a class="header-anchor" href="#查看索引" aria-hidden="true">#</a></h4><div class="language-sql line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">sql</span><pre class="shiki material-palenight"><code><span class="line"><span style="color:#A6ACCD;">SHOW </span><span style="color:#F78C6C;">INDEX</span><span style="color:#A6ACCD;"> </span><span style="color:#F78C6C;">FROM</span><span style="color:#A6ACCD;"> 表名;</span></span>
<span class="line"></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br></div></div><h4 id="删除索引" tabindex="-1">删除索引 <a class="header-anchor" href="#删除索引" aria-hidden="true">#</a></h4><div class="language-sql line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">sql</span><pre class="shiki material-palenight"><code><span class="line"><span style="color:#F78C6C;">DROP</span><span style="color:#A6ACCD;"> </span><span style="color:#F78C6C;">INDEX</span><span style="color:#A6ACCD;"> 索引名 </span><span style="color:#F78C6C;">ON</span><span style="color:#A6ACCD;"> 表名;</span></span>
<span class="line"></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br></div></div><h3 id="sql-性能分析工具" tabindex="-1">SQL 性能分析工具 <a class="header-anchor" href="#sql-性能分析工具" aria-hidden="true">#</a></h3><h4 id="sql-执行频率" tabindex="-1">SQL 执行频率 <a class="header-anchor" href="#sql-执行频率" aria-hidden="true">#</a></h4><p>MySQL 客户端连接成功后，通过 <code>show [session | global] status</code> 命令可以提供服务器状态信息。通过如下指令，可以查看当前数据库的 INSERT 、 UPDATE、DELETE、SELECT 的执行频率：</p><p>下面是一个固定语法，7 个下划线</p><div class="language-sql line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">sql</span><pre class="shiki material-palenight"><code><span class="line"><span style="color:#A6ACCD;">SHOW </span><span style="color:#F78C6C;">GLOBAL</span><span style="color:#A6ACCD;"> </span><span style="color:#F78C6C;">STATUS</span><span style="color:#A6ACCD;"> </span><span style="color:#F78C6C;">LIKE</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">&#39;</span><span style="color:#C3E88D;">Com_______</span><span style="color:#89DDFF;">&#39;</span><span style="color:#A6ACCD;">;</span></span>
<span class="line"></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br></div></div><h4 id="慢查询日志" tabindex="-1">慢查询日志 <a class="header-anchor" href="#慢查询日志" aria-hidden="true">#</a></h4><p>慢查询日志记录了所有执行时间超过指定参数(long_query_time，单位 秒，默认 10 秒) 的所有 SQL 语句的日志。</p><p>查询是否开启慢查询日志开关：</p><div class="language-bash line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">bash</span><pre class="shiki material-palenight"><code><span class="line"><span style="color:#FFCB6B;">show</span><span style="color:#A6ACCD;"> </span><span style="color:#C3E88D;">variables</span><span style="color:#A6ACCD;"> </span><span style="color:#C3E88D;">like</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">&#39;</span><span style="color:#C3E88D;">slow_query_log</span><span style="color:#89DDFF;">&#39;</span><span style="color:#89DDFF;">;</span></span>
<span class="line"></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br></div></div><p>MySQL 的慢查询日志默认没有开启， 需要在 MySQL 的配置文件（etc/my.cnf）中进行配置：</p><div class="language-bash line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">bash</span><pre class="shiki material-palenight"><code><span class="line"><span style="color:#676E95;font-style:italic;"># 开启慢查询日志</span></span>
<span class="line"><span style="color:#A6ACCD;">slow_query_log</span><span style="color:#89DDFF;">=</span><span style="color:#F78C6C;">1</span></span>
<span class="line"><span style="color:#676E95;font-style:italic;"># 设置慢查询日志超时时间，查询时超过这个时间就会被记录</span></span>
<span class="line"><span style="color:#A6ACCD;">long_query_time</span><span style="color:#89DDFF;">=</span><span style="color:#F78C6C;">2</span></span>
<span class="line"></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br></div></div><h4 id="profile-详情" tabindex="-1">Profile 详情 <a class="header-anchor" href="#profile-详情" aria-hidden="true">#</a></h4><p>show profiles 能够在做 SQL 优化时帮助我们了解时间都耗费到哪儿了，通过 have_profiling 参数，能够看到当前 MySQL 是否支持 profile 操作：</p><div class="language-sql line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">sql</span><pre class="shiki material-palenight"><code><span class="line"><span style="color:#F78C6C;">SELECT</span><span style="color:#A6ACCD;"> @@have_profiling;</span></span>
<span class="line"></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br></div></div><p>默认 profiling 是关闭的，可以通过 set 语句在 session/global 级别开启 profiling：</p><div class="language-sql line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">sql</span><pre class="shiki material-palenight"><code><span class="line"><span style="color:#F78C6C;">SET</span><span style="color:#A6ACCD;"> profiling </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> </span><span style="color:#F78C6C;">1</span><span style="color:#A6ACCD;">;</span></span>
<span class="line"></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br></div></div><h5 id="相关语法" tabindex="-1">相关语法 <a class="header-anchor" href="#相关语法" aria-hidden="true">#</a></h5><div class="language-sql line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">sql</span><pre class="shiki material-palenight"><code><span class="line"><span style="color:#A6ACCD;"># 查看每一条 </span><span style="color:#F78C6C;">SQL</span><span style="color:#A6ACCD;"> 的执行基本耗时情况：</span></span>
<span class="line"><span style="color:#A6ACCD;">show profiles;</span></span>
<span class="line"></span>
<span class="line"><span style="color:#A6ACCD;"># 查看指定 query_id 的 </span><span style="color:#F78C6C;">SQL</span><span style="color:#A6ACCD;"> 语句各个阶段的耗时情况</span></span>
<span class="line"><span style="color:#A6ACCD;">show </span><span style="color:#F78C6C;">profile</span><span style="color:#A6ACCD;"> for query query_id;</span></span>
<span class="line"></span>
<span class="line"><span style="color:#A6ACCD;"># 查看指定 query_id 的 </span><span style="color:#F78C6C;">SQL</span><span style="color:#A6ACCD;"> 语句 CPU 的使用情况</span></span>
<span class="line"><span style="color:#A6ACCD;">show </span><span style="color:#F78C6C;">profile</span><span style="color:#A6ACCD;"> cpu for query query_id;</span></span>
<span class="line"></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br></div></div><h4 id="explain-执行计划-最重要" tabindex="-1">explain 执行计划（最重要） <a class="header-anchor" href="#explain-执行计划-最重要" aria-hidden="true">#</a></h4><p>explain 或者 desc 命令获取 MySQL 如何执行 SELECT 语句的信息，包括在 SELECT 语句执行过程中表如何进行连接和连接的顺序。</p><p>语法：</p><div class="language-sql line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">sql</span><pre class="shiki material-palenight"><code><span class="line"><span style="color:#A6ACCD;"># 直接在 </span><span style="color:#F78C6C;">select</span><span style="color:#A6ACCD;"> 语句之前加上关键字 explain </span><span style="color:#89DDFF;">/</span><span style="color:#A6ACCD;"> </span><span style="color:#F78C6C;">desc</span></span>
<span class="line"><span style="color:#F78C6C;">desc</span><span style="color:#A6ACCD;"> </span><span style="color:#F78C6C;">select</span><span style="color:#A6ACCD;"> 字段列表 </span><span style="color:#F78C6C;">from</span><span style="color:#A6ACCD;"> 表名 </span><span style="color:#F78C6C;">where</span><span style="color:#A6ACCD;"> 条件;</span></span>
<span class="line"></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><h5 id="字段含义" tabindex="-1">字段含义 <a class="header-anchor" href="#字段含义" aria-hidden="true">#</a></h5><ul><li>id： select 查询的序列号，表示查询中执行 select 子句或者是操作表的顺序（ id 相同，执行顺序从上到下；id 不同，值越大，越先执行）</li><li>select_type：表示 SELECT 的类型，常见的有 SIMPLE (简单表，即不使用表连接或者子查询)、 PRIMARY（主查询，即外层查询）、UNION（UNION 中的第二个或者后面的查询语句）、SUBQUERY（SELECT/WHERE 之后包含了子查询）等</li><li>type：表示连接类型，性能由好到差的连接类型为 NULL 、system、const、eq_ref、ref、range、index、all；根据主键或者一般的索引来访问查询，一般都是 const 或者 eq_ref， NULL 在业务系统中不太可能出现，除非不访问表。</li><li>possible_key：可能在这张表中用到的索引，一个或多个。</li><li>key：实际使用的索引，如果为 null，说明没用索引</li><li>key_len：表示索引中使用的字节数，该值为索引字段最大可能长度，并非实际使用长度，不损失精度的前提下，越短越好</li><li>rows：MySQL 认为必须要查询的行数，在 innoDB 的表中，是一个估计值，并不总是准确的</li><li>filtered：表示返回结果的行数占需读取行数的百分比，该值越大越好。</li></ul><h3 id="索引使用" tabindex="-1">索引使用 <a class="header-anchor" href="#索引使用" aria-hidden="true">#</a></h3><h4 id="验证索引效率" tabindex="-1">验证索引效率 <a class="header-anchor" href="#验证索引效率" aria-hidden="true">#</a></h4><ul><li><p>在未建立索引之前，先执行一个 SQL 语句，查看 SQL 耗时多少</p></li><li><p>针对相关字段建立索引（如果数据量太大，建立索引的时间可能会比较长）</p></li><li><p>然后再执行相同的 SQL 语句，再次查看查询耗时</p></li></ul><h4 id="索引使用原则" tabindex="-1">索引使用原则 <a class="header-anchor" href="#索引使用原则" aria-hidden="true">#</a></h4><h5 id="最左前缀法则" tabindex="-1">最左前缀法则 <a class="header-anchor" href="#最左前缀法则" aria-hidden="true">#</a></h5><p>如果索引了多列（联合索引），要遵守最左前缀法则。指的是查询从索引的最左列开始，并且不跳过索引中的列。如果跳过了索引中的某一列，索引将部分失效（这一列后面的字段索引失效），跟书写查询字段的顺序无关。</p><h5 id="范围查询" tabindex="-1">范围查询 <a class="header-anchor" href="#范围查询" aria-hidden="true">#</a></h5><p>联合索引中，出现范围查询（&gt;，&lt;），范围查询右侧的列索引失效，规避的方法是不使用 （ &gt;, &lt; ），在业务允许时改成（ &gt;=, &lt;= )。</p><p>如下面的 status = &#39;0&#39; 索引将会失效。</p><div class="language-sql line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">sql</span><pre class="shiki material-palenight"><code><span class="line"><span style="color:#F78C6C;">select</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">*</span><span style="color:#A6ACCD;"> </span><span style="color:#F78C6C;">from</span><span style="color:#A6ACCD;"> user </span><span style="color:#F78C6C;">where</span><span style="color:#A6ACCD;"> major </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">&#39;</span><span style="color:#C3E88D;">软件工程</span><span style="color:#89DDFF;">&#39;</span><span style="color:#A6ACCD;"> </span><span style="color:#F78C6C;">and</span><span style="color:#A6ACCD;"> age </span><span style="color:#89DDFF;">&gt;</span><span style="color:#A6ACCD;"> </span><span style="color:#F78C6C;">30</span><span style="color:#A6ACCD;"> </span><span style="color:#F78C6C;">and</span><span style="color:#A6ACCD;"> </span><span style="color:#F78C6C;">status</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">&#39;</span><span style="color:#C3E88D;">0</span><span style="color:#89DDFF;">&#39;</span><span style="color:#A6ACCD;">;</span></span>
<span class="line"></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br></div></div><h5 id="索引列运算" tabindex="-1">索引列运算 <a class="header-anchor" href="#索引列运算" aria-hidden="true">#</a></h5><p>不要在索引列上进行运算操作，否则索引将失效 ，比如通过调用函数来进行查询。</p><h5 id="字符串类型不加引号" tabindex="-1">字符串类型不加引号 <a class="header-anchor" href="#字符串类型不加引号" aria-hidden="true">#</a></h5><p>比如查询某一个手机号的时候， phone = 后面的手机号不加引号，索引会失效</p><div class="language-sql line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">sql</span><pre class="shiki material-palenight"><code><span class="line"><span style="color:#F78C6C;">select</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">*</span><span style="color:#A6ACCD;"> </span><span style="color:#F78C6C;">from</span><span style="color:#A6ACCD;"> user </span><span style="color:#F78C6C;">where</span><span style="color:#A6ACCD;"> phone </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> </span><span style="color:#F78C6C;">18577777777</span></span>
<span class="line"></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br></div></div><h5 id="模糊查询" tabindex="-1">模糊查询 <a class="header-anchor" href="#模糊查询" aria-hidden="true">#</a></h5><p>如果是尾部模糊匹配，索引不会失效，如果是头部模糊匹配，索引将失效，要避免头部加模糊匹配的情况。</p><div class="language-sql line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">sql</span><pre class="shiki material-palenight"><code><span class="line"><span style="color:#F78C6C;">select</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">*</span><span style="color:#A6ACCD;"> </span><span style="color:#F78C6C;">from</span><span style="color:#A6ACCD;"> user </span><span style="color:#F78C6C;">where</span><span style="color:#A6ACCD;"> major </span><span style="color:#F78C6C;">like</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">&#39;</span><span style="color:#C3E88D;">%工程</span><span style="color:#89DDFF;">&#39;</span><span style="color:#A6ACCD;">;</span></span>
<span class="line"></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br></div></div><h5 id="or-连接的条件" tabindex="-1">or 连接的条件 <a class="header-anchor" href="#or-连接的条件" aria-hidden="true">#</a></h5><p>用 or 分割的条件，如果 or 前的条件中的列有索引，而后面的列没有索引，那么涉及的索引都不会被用到。</p><h5 id="数据分布影响" tabindex="-1">数据分布影响 <a class="header-anchor" href="#数据分布影响" aria-hidden="true">#</a></h5><p>如果 MySQL 评估使用索引比全表扫描更慢 ，则不使用索引</p><h5 id="sql-提示" tabindex="-1">SQL 提示 <a class="header-anchor" href="#sql-提示" aria-hidden="true">#</a></h5><p>优化数据库的一个重要手段，简单说就是人为告诉 MySQL 使用什么索引来达到优化的手段</p><p>use index（建议 MySQL 使用该索引，MySQL 还是会评估要不要用）</p><div class="language-sql line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">sql</span><pre class="shiki material-palenight"><code><span class="line"><span style="color:#A6ACCD;">explain </span><span style="color:#F78C6C;">select</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">*</span><span style="color:#A6ACCD;"> </span><span style="color:#F78C6C;">from</span><span style="color:#A6ACCD;"> user </span><span style="color:#F78C6C;">use</span><span style="color:#A6ACCD;"> </span><span style="color:#F78C6C;">index</span><span style="color:#A6ACCD;">(idx_user_major) </span><span style="color:#F78C6C;">where</span><span style="color:#A6ACCD;"> major </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">&#39;</span><span style="color:#C3E88D;">软件工程</span><span style="color:#89DDFF;">&#39;</span><span style="color:#A6ACCD;">;</span></span>
<span class="line"></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br></div></div><p>ignore index（忽略使用该索引）</p><div class="language-sql line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">sql</span><pre class="shiki material-palenight"><code><span class="line"><span style="color:#A6ACCD;">explain </span><span style="color:#F78C6C;">select</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">*</span><span style="color:#A6ACCD;"> </span><span style="color:#F78C6C;">from</span><span style="color:#A6ACCD;"> user </span><span style="color:#F78C6C;">ignore</span><span style="color:#A6ACCD;"> </span><span style="color:#F78C6C;">index</span><span style="color:#A6ACCD;">(idx_user_major) </span><span style="color:#F78C6C;">where</span><span style="color:#A6ACCD;"> major </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">&#39;</span><span style="color:#C3E88D;">软件工程</span><span style="color:#89DDFF;">&#39;</span><span style="color:#A6ACCD;">;</span></span>
<span class="line"></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br></div></div><p>force index（必须，强制 MySQL 使用该索引）:</p><div class="language-sql line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">sql</span><pre class="shiki material-palenight"><code><span class="line"><span style="color:#A6ACCD;">explain </span><span style="color:#F78C6C;">select</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">*</span><span style="color:#A6ACCD;"> </span><span style="color:#F78C6C;">from</span><span style="color:#A6ACCD;"> user </span><span style="color:#F78C6C;">force</span><span style="color:#A6ACCD;"> </span><span style="color:#F78C6C;">index</span><span style="color:#A6ACCD;">(idx_user_major) </span><span style="color:#F78C6C;">where</span><span style="color:#A6ACCD;"> major </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">&#39;</span><span style="color:#C3E88D;">软件工程</span><span style="color:#89DDFF;">&#39;</span><span style="color:#A6ACCD;">;</span></span>
<span class="line"></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br></div></div><h5 id="覆盖索引" tabindex="-1">覆盖索引 <a class="header-anchor" href="#覆盖索引" aria-hidden="true">#</a></h5><p>尽量使用覆盖索引（查询使用了索引，并且需要返回的列，在该索引中已经全部能够找到），减少 select _ 这种语法的使用。也就是说你建立了索引的字段，尽可能去在 select 中去查找已经进行索引的列，而不要通过 _ 把所有列的数据返回。</p><p>因为如果去查询没进行索引的列时，还会需要回表查询。</p><p>进行 explain 查询时，需要关注的是 extra 字段：</p><p>using index condition： 查找使用了索引，但是需要回表查询数据</p><p>using where; using index：查找使用了索引，但是需要的数据都在索引列中能找到，所以不需要回表查询数据</p><h5 id="思考-1" tabindex="-1">思考 <a class="header-anchor" href="#思考-1" aria-hidden="true">#</a></h5><p>一张表有 4 个字段(id，username，password，status) 由于数据量大，需要对下面的 SQL 进行优化，说出最佳优化方案：</p><div class="language-sql line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">sql</span><pre class="shiki material-palenight"><code><span class="line"><span style="color:#F78C6C;">select</span><span style="color:#A6ACCD;"> id, username, </span><span style="color:#F78C6C;">password</span><span style="color:#A6ACCD;"> </span><span style="color:#F78C6C;">from</span><span style="color:#A6ACCD;"> user </span><span style="color:#F78C6C;">where</span><span style="color:#A6ACCD;"> username </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">&#39;</span><span style="color:#C3E88D;">dachui</span><span style="color:#89DDFF;">&#39;</span><span style="color:#A6ACCD;">;</span></span>
<span class="line"></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br></div></div><p>针对 username 和 password 建立联合索引即可，这样可以避免回表查询，只需要在二级索引中查询一次即可。如果只针对 username 建立索引的话，二级索引中找不到 password， 还会需要去聚集索引中进行一次回表查询。</p><h5 id="前缀索引" tabindex="-1">前缀索引 <a class="header-anchor" href="#前缀索引" aria-hidden="true">#</a></h5><p>当字段类型为字符串时，有时候需要索引很长的字符串，这会让索引变得很大，查询时，浪费大量的磁盘 IO，影响查询效率，此时可以只将字符串的一部分前缀作为索引，大大节省索引空间，从而提高索引效率。</p><p>语法：</p><p>n 代表要在字符串的前面几个字符来构建索引</p><div class="language-sql line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">sql</span><pre class="shiki material-palenight"><code><span class="line"><span style="color:#F78C6C;">create</span><span style="color:#A6ACCD;"> </span><span style="color:#F78C6C;">index</span><span style="color:#A6ACCD;"> </span><span style="color:#82AAFF;">索引名称</span><span style="color:#A6ACCD;"> </span><span style="color:#F78C6C;">on</span><span style="color:#A6ACCD;"> 表名(字段名(n));</span></span>
<span class="line"></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br></div></div><p>前缀长度：</p><p>可以根据索引的选择性来决定，而选择性是指不重复的索引值（基数）和数据表的记录总数的比值，索引选择性越高则查询效率越高，唯一索引的选择性是 1，这是最好的选择性，性能也最好；</p><div class="language-sql line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">sql</span><pre class="shiki material-palenight"><code><span class="line"><span style="color:#F78C6C;">select</span><span style="color:#A6ACCD;"> </span><span style="color:#82AAFF;">count</span><span style="color:#A6ACCD;">(</span><span style="color:#F78C6C;">distinct</span><span style="color:#A6ACCD;"> email) </span><span style="color:#89DDFF;">/</span><span style="color:#A6ACCD;"> </span><span style="color:#82AAFF;">count</span><span style="color:#A6ACCD;">(</span><span style="color:#89DDFF;">*</span><span style="color:#A6ACCD;">) </span><span style="color:#F78C6C;">from</span><span style="color:#A6ACCD;"> user;</span></span>
<span class="line"></span>
<span class="line"><span style="color:#F78C6C;">select</span><span style="color:#A6ACCD;"> </span><span style="color:#82AAFF;">count</span><span style="color:#A6ACCD;">(</span><span style="color:#F78C6C;">distinct</span><span style="color:#A6ACCD;"> </span><span style="color:#82AAFF;">substring</span><span style="color:#A6ACCD;">(email, </span><span style="color:#F78C6C;">1</span><span style="color:#A6ACCD;">, </span><span style="color:#F78C6C;">5</span><span style="color:#A6ACCD;">)) </span><span style="color:#89DDFF;">/</span><span style="color:#A6ACCD;"> </span><span style="color:#82AAFF;">count</span><span style="color:#A6ACCD;">(</span><span style="color:#89DDFF;">*</span><span style="color:#A6ACCD;">) </span><span style="color:#F78C6C;">from</span><span style="color:#A6ACCD;"> user;</span></span>
<span class="line"></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><h5 id="单列索引和联合索引" tabindex="-1">单列索引和联合索引 <a class="header-anchor" href="#单列索引和联合索引" aria-hidden="true">#</a></h5><p>单列：一个索引只有一个字段</p><p>联合：一个索引包含多个字段</p><p>在业务场景中，如果存在多个查询条件，考虑针对于查询字段建立索引时，建议建立联合索引，而非单列索引</p><h3 id="索引设计原则" tabindex="-1">索引设计原则 <a class="header-anchor" href="#索引设计原则" aria-hidden="true">#</a></h3><ol><li><p>针对数据量较大（数据量超过 100W），并且查询频繁的表建立索引</p></li><li><p>针对常用于查询条件（where）、排序（order by）、分组（group by）操作的字段建立索引。</p></li><li><p>尽量选择区分度高的列作为索引，尽量建立唯一索引，区分度越高，使用索引的效率越高</p></li><li><p>如果是字符串类型的字段，字段的长度较长，可以针对字段的特点，建立前缀索引</p></li><li><p>尽量使用联合索引，减少单列索引，查询时，联合索引很多时候可以覆盖索引，节省存储空间，避免回表，提高查询效率</p></li><li><p>要控制索引的数量，索引并不是多多益善，索引越多，维护索引结构的代价越大，会影响 <strong>增删改</strong> 的效率</p></li><li><p>如果索引列不能存储 NULL 值，请在创建表时使用 NOT NULL 约束。当优化器知道每列是否包含 NULL 值时，它可以更好的确定哪个索引最有效用于查询。</p></li></ol>`,182),r=[p];function t(o,i,c,d,C,h){return n(),a("div",null,r)}const u=s(l,[["render",t]]);export{A as __pageData,u as default};
